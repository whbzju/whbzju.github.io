<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Wujia Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content><meta name=generator content="Hugo 0.104.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><link href=/posts/index.xml rel=alternate type=application/rss+xml title="Wujia Blog"><link href=/posts/index.xml rel=feed type=application/rss+xml title="Wujia Blog"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://whbzju.github.io/posts/"><meta itemprop=name content="Posts"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content></head><body class="ma0 avenir bg-near-white"><header><div class="pb3-m pb6-l bg-black"><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Wujia Blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav><div class="tc-l pv3 ph3 ph4-ns"><h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">Posts</h1></div></div></header><main class=pb7 role=main><article class="pa3 pa4-ns nested-copy-line-height"><section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section><section class="flex-ns flex-wrap justify-around mt5"><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/bianchengzhihuidiao/ class="link black dim">编程小扎之回调</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">在我的认知中，编程最需要要关心的是数据结构和消息机制。进一步，即模块功能的定义，以及模块之间的通信。这和编程中的回调机制十分类似。回调在wiki中有如下定义：
In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback. The ways that callbacks are supported in programming languages differ, but they are often implemented with subroutines, lambda expressions, blocks, or function pointers.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/c-yuyuan/ class="link black dim">C专家编程摘要</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">上个月经人推荐，看了这本《C专家编程》，大赞，推荐用C的人都去看看。除了能从历史上了解 C语言的一些语法，还能学到一些常用规范。特别是指针和数组部分，很有收获。 用一张思维导向图总结</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/renlianshibiezongjie/ class="link black dim">人脸识别实践总结</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">#概述 前段时间接触了一阵子人脸识别，只能说是初窥门道，在这里做个总结。本文不涉及具体的算法原理，因为我都是参考别人的资料，只认为无法写的更好，在这边做个归纳总结。 现需求如下：从摄像头视频中识别出你自己或朋友的人脸
要实现这个需求，大体分为两个步骤，分别为人脸检测和人脸识别，即先要从摄像头中识别出人脸，即人脸检测，其次对检测到的人脸进行识别，即人脸识别。本文基于Opencv的人脸算法实现。
##人脸检测流程
选取特征（本文采用Haar-like特征） 选取分类器算法，训练人脸分类器（本文采用Adaboost级联分类器） 对图像进行人脸检测 ##人脸识别流程
选取人脸识别算法（本文包括PCA、FDA和LBP） 训练识别模型 对目标进行识别 #Opencv相关资料介绍 opencv在2.4后引入了人脸识别相关模块，原来只有人脸检测部分。在Opencv官网，有较详细的介绍，看 !目录，在该目录中重点要看这篇!Face Recognition with OpenCV.
这应该是一个德国人写的，在教程中他提到了3个算法：
EigenFaces FisherFace Local Binary Patterns Histograms 前面两个算法都是利用子空间的原理，有一定的相似性，分别以PCA和LDA为基础。后者以特征选取为主，做法思路都不大一样，建议分开看。该教程中对算法的描述过于简洁，不适合初学者看，建议寻找相关资料进一步阅读。 ##PCA-主成分分析法 PCA在很多地方都有应用，是一个十分简单有效的方法。其思想概括起来即降维，它认为原始数据中包含了大量的噪音和冗余，通过协方差矩阵的对角化可以得到一个子空间，该子空间的维度大大降低，却神奇的保留了原始数据中的显著特征。
该算法的具体原理可参考斯坦福大学的公开课，Andrew.Ng的机器学习课程，里面有一章节专门讲pca，若觉得看视频太慢，可以直接看讲义，讲的很清楚。国内有几个博客作者对它进行了翻译，推荐：
!主成分分析（Principal components analysis）-最大方差解释
!机器学习中的数学(4)-线性判别分析（LDA）, 主成分分析(PCA)
该算法涉及较多的线性代数知识，忘掉的同学建议复习下相关内容。
##LDA-线性判别分析 fisherface的FDA是在LDA基础之上的一种算法。关于线性判别的思想如下：它认为在PCA中，PCA把数据作为一个整体来看，即数据源中所有的显著特征都会被保留下来，如果一个人的脸在强光下和弱光下，pca生成的子空间有显著的差异，而他们却是同一张脸。LDA的思想是寻找一个分割平面（在二维中即直线），来区分两种不同类别的数据，既能够区分两个不同的人脸，进行归类。因此，它的目标就是怎么要找到这个平面，达到最好的区分效果。
同样，该算法的具体原理还是推荐Andrew.Ng的机器学习公开课。国内也有相关介绍，但是他们的数学推导让我不满意。
!线性判别分析（Linear Discriminant Analysis）（一） !线性判别分析（Linear Discriminant Analysis）（二）
##LBPH 该算法较上面二者容易理解，这里不做详细介绍，大家自己查找相关资料即可。
##Demo 上面教程中提到几个算法opencv中都有例子实现，当然要做2.4以上。教程讲了demo的位置和具体的使用。 所有的Demo需要一个人脸库，教程中提供了几个，可以下载。下载下来的人脸库需要预处理，即打上标签，作者提供了python脚步，大家可以使用。
有个demo值得关注，它实现了我们的需求，它有个专门的教程：!Face Recognition in Videos with OpenCV. 不过要想识别自己的脸，必须将自己的脸裁剪下来保存到人脸库中进行训练。
我不想自己拍照片去裁剪，我的做法是利用demo中的人脸检测算法，将我的人脸检测到，然后保存成灰度图，放到人脸库中。PS：这里有个问题，opencv自带的人脸检测分类器有可能会误捡，会把空白的墙壁当做人脸。我的做法是，在视频中指定一个矩形框，在这个矩形框中进行人脸检测，这样可以大大降低误捡率。实际操作中可以调整位置，让自己的人脸出现在矩形框中。
#Haar-like特征Adaboost级联分类器 完成了人脸识别的Demo验证，大家一定很好奇人脸检测是怎么实现的。opencv里面自带的检测算法原至两篇论文： P. Viola and M. Jones. Rapid object detection using a boosted cascade of simple features.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/qianxi-jni-3/ class="link black dim">浅析JNI（三）</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">没想到这个话题写到第三篇博客，写blog真费时，我的周末没了。接上文继续： PS更新:这篇blog一拖就是一个月，主要是我太懒了。其次是在公司写的东西不能带出来，每次要写这方面的资料，必须重写一些demo进行说明，重复劳动，没有动力。
#内容概述
JNI数据类型 JNIEnv介绍 ##JNI数据类型介绍
基本数据类型 先来看一张图： 可以明显的看出JNI的数据类型只是比java的基本数据类型多了个j。
引用数据类型 同样看图： 可以看出所有的引用类型都是jobject，和java类似。不过jni里面对jstring单独做了处理，就叫jstring类型，估计是用的频率太高，如果也是jobject会涉及到大量的“装箱拆箱“吧。
##JNIEnv介绍 JNIEnv是jni中举足轻重的一个角色，env可以理解成window中的句柄，线程中的线程描述符，或者简单理解成当前的上下文环境变量。在java VM中，它是一个局部引用，因此无法作为全局引用保存下来，每次在jni调用时，都要重新获取下env，因为env有可能会发生变化。
##实例讲解&ndash;Jni回调java 在工作中，我们使用jni时，常常会碰到需要从native回调java的需求，比如java通过jni调用native的一些函数，如果这些函数较为耗时，经常会起一个线程来完成任务，那么当任务完成时，必然要告诉java层。通常的做法是java层通过jni设置回调函数，native通过jni回调java。先看代码：
public class jniActivity extends Activity {
private TextView tv; //private String test; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); SetJniCallBack(); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // Java通过该方法设置回调方法 public native void SetJniCallBack(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/gongkaikedianpian/ class="link black dim">转：公开课点评（收藏用）</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">#原文 !链接
今天在图灵Q群里聊到一些公开课心得。群友隋春宁建议我总结一下、发到社区。我也觉得这些信息可能对公开课同好有帮助，遂总结如下：
我觉得比较好的课程：
Algorithms: Design and Analysis, Part 1 和 Part2 都挺好的，算是理论和实践结合得很好、难度介于入门和专业之间的课程。
Web Intelligence and Big Data 涉及的面比较广，但每个点讲得都不深。如果想对这个领域有个全面了解和认识，可以听一下。不过讲课人略带口音，听起来有点别扭。
几门复杂网络（社交网络、经济网络分析等）课程都相当不错：Networked Life、Social Network Analysis、Social and Economic Networks: Models and Analysis，（还有一门 Networks: Friends, Money, and Bytes，我没听过，但据其他人评价应该不错），我从中学到了很多。而且我想，这里的概念和机器学习的联系也都是很紧密的。但复杂网络（其实大多是图论知识了）和机器学习的交叉，现在做的人还不太多，基本上物理和计算机两边还都是各做各的。这一块未来应该有不小发展空间。
Image and video processing: From Mars to Hollywood with a stop at the hospital 和 Computational Photography 都是入门课，适合想对图像处理有所了解的人听。讲课这两位老师都是大牛，算是深入浅出吧。
Functional Programming Principles in Scala，语言大师、Scala 创始人 Martin Odersky 亲授。我虽然没跟完，只听和做了前面三到四周的课和作业，但感觉很有收获。编程作业应该和 sicp 蛮相关的。能领会不少函数式编程的精神。
Neural Networks for Machine Learning，这门课由神经网络和深度学习的宗师 Geoffrey Hinton 开设，也是覆盖面很广。如果先对神经网络有一些了解与实践，再来听可能收获会更大。我就是当时听的时候很多东西都没理解，现在仍然在反复看。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/qianxi-jni-2/ class="link black dim">浅析JNI（二）</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">上文：浅析JNI中提到，静态注册方法有不少弊端，和现在的链接方式方式分静态链接和动态链接相识，jni技术中还有动态注册，本文将详细介绍其实现机制和原理。
#动态注册
##Java层 先看代码，为hello-jni的java层添加动态注册的native方法，与静态注册的native方法比较。
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), "Call from Native", Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System.loadLibrary("learn-jni"); } }</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/qianxi-jni/ class="link black dim">浅析JNI(一)</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">最近的项目和一些图像处理有关，需要用C、C++实现，生成so文件，再通过JNI结合到Android的app中，有时候项目需要还会查看android的源码，做些调整，也会涉及到许多so文件，了解了一些JNI的技术。并且，正在读的一本书叫《深入理解Android》卷一，作者：邓平凡。该书是写的深入浅出，作者功力深厚，大力推荐购买。本文关于JNI的技术大部分参考该书第二章的内容，有兴趣的同学可以购买该书查看原文，这里作为我个人关于JNI的知识整理。
在进入正题之前，需要读者了解一些预备知识，比如关于JNI环境的配置，第一个jni程序hello-jni实现，具体参考：http://whbzju.github.io/blog/2013/06/01/android-jni-config/
#内容概述 本文从以下4个部分进行：
Java层，声明、使用native方法 Java与Native如何关联，即注册的方式与实现 Java与Native方法通信，即如何互相调用 Java与Native的数据结构对应关系 我相信，如果你弄懂了以上的问题，可以使用jni技术进行基本的开发。本文通过实现一个简单的demo，对以上的问题的进行解答。
#Java层&mdash;声明、使用native方法 先看MediaScanner.java的代码
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); tv.setText( stringFromJNI() ); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 //public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), "Call from Native", Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System.</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/ruzhilianggeyuezongjie/ class="link black dim">入职两月总结</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">好久没有写博客，一是工作后时间不是自己，每天很晚下班，回到家，洗洗差不多就要睡了。二是公司信息安全管的很严，资料带不出来，工作方面的积累不方便写到博客上，每次想起要重新写自己写过的东西，就很没有动力。
本周过后，入职已经两个月了，公司的体制不想也没有资格评论，做的项目确是我很满意的，只能说塞翁失马焉知非福，找工作的时候千挑万选，也看不清进来后的项目，目前的情况还算幸运。现在的项目组涉及到的领域有Android开发、人脸识别、机器学习等，而且作为一个新的项目，我有幸可以从头开始接触整个项目。
##成长
Android源码环境调试app、系统组件 Android 4.0 人脸解锁app研究 Android JNI技术学习 人脸识别算法PCA、FDA、LBP学习 人脸检测HaarCascade学习 Opencv 人脸识别 Demo研究：Eigenface、fisherFaces、LBP。 机器学习LDA、贝叶斯学习 ##博客计划 后续博客将集中在三个领域
Android技术：分为源码和应用开发技术 人脸识别：集中于机器学习的方式实现 机器学习：未来重点 计划中的blog：
Android JNI技术简介 Android调试小技巧 PCA之我的理解 fisherFaces之我的理解 Opencv人脸识别Demo ADB的使用详解 Haar分类器训练 欠了好多，这些内容我在公司都有写过文档，可惜不能直接用，希望在整理的过程中有进一步的理解。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/android-jni-config/ class="link black dim">Android JNI MAC OS环境配置</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height">##前言&mdash;JNI技术简介 JNI是Java Native Interface的缩写，即“Java本地调用”，它是Java世界和Native世界的中介桥梁。其中Native世界一般指C/C++的世界。众所周知，Java是一种跨平台的语言，即Java编写的应用与平台无关。但是，计算机的世界在Java出现之前已经发展了很久，有很多优秀健壮的代码可以复用。比如Linux下的好多驱动模块、文件系统等。Java若去重新实现这些功能，未免费力不讨好，落下重复造轮子的名声。通过JNI技术，使用这些Native的模块，便成了一个折中的办法。同时，Java的世界依靠虚拟机构建，而虚拟机是native语言实现，并且虚拟机运行在具体的平台上，所以虚拟机本身是无法做到平台无关。通过JNI技术，可能做到在Java层的平台无关，即在Java层，底层的细节完全被屏蔽掉了。综合来讲，JNI技术一直支撑这Java世界，只不过我们平时接触的较少。
在Android的世界里，不允许纯C/C++的程序出现，但是它支持JNI，通过JNI来实现java和C/C++的交互。因此，JNI对于需要接触到Android源码、底层驱动、图形图像等领域的开发者来讲异常重要。
在Android中，Native语言实现的代码最终要编译成*.so动态库的方式，供java层调用，目前有两种途径实现。
##两种编译环境
源码编译环境：Android平台提供基于Make的编译环境，为App正确的编写Android.mk即可使用该编译环境，该环境需要通过git从Android的官方的源码平台获取源码并编译，得到环境。具体见：http://source.android.com/index.html 基于Android NDK的编译环境:NDK的全称叫做Native Development Kit。是google提供给我们用于本地编译JNI的工具。事实上，NDK和源码编译环境一样，都是使用Android的编译系统，通过Android.mk来控制编译。本文重点介绍这种方式。 ##NDK编译环境 在Mac下，配置NDK的环境十分简便，你只需要去官网下载ndk包，前提是你已经安装好ndk需要的工具，一般你如果安装过xcode，基本的环境都会有。解压缩到任意一个目录下，把该目录加到你的PATH中即可。比如我的：
在~/.bash_profile中把路径加入PATH，如果没有，可以创建一个.bash_profile，在最后加入下面语句。
export PATH=$PATH:/Users/youpath/android-ndk-r8e 重启bash，即可使用ndk-build
HaibotekiMacBook-Air:jni haibowu$ source ~/.bash_profile HaibotekiMacBook-Air:jni haibowu$ ndk-build ##运行Hello-jni ndk包解压缩之后，自带一些jni的例子，下面我们就来编译运行下hello-jni，感觉下jni的世界。该demo的路径在ndk安装路径的sample目录下。进入该路径，执行下列命令：
HaibotekiMacBook-Air:jni haibowu$ ndk-build Gdbserver : [arm-linux-androideabi-4.6] libs/armeabi/gdbserver Gdbsetup : libs/armeabi/gdb.setup Compile thumb : hello-jni &lt;= hello-jni.c SharedLibrary : libhello-jni.so Install : libhello-jni.so => libs/armeabi/libhello-jni.so 当系统提示生成*.so文件时，即代表编译成功。可以通过eclipse或者intellij idea导入该工程，运行查看效果。
##其他
如果你有android源码编译环境，你可以通过编写android.mk来编译app 如果你是在window下使用ndk，你需要安装cygwin，来模拟linux的环境，才能把ndk安装成功，其思想是一直的。参考：http://www.cnblogs.com/luxiaofeng54/archive/2011/08/13/2136982.html ndk是一个开发工具包，你也可以查看它的源码、进行编译，具体参考：http://glandium.org/blog/?p=2146 ##后续 接下来，我会写一篇介绍Jni的blog，希望能写的浅显易懂。</div></div></div></div><div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height"><div class="bg-white mb3 pa4 gray overflow-hidden"><span class="f6 db">Posts</span><h1 class="f3 near-black"><a href=/posts/lianjiatingsanbuqu/ class="link black dim">李安家庭三部曲杂想</a></h1><div class="nested-links f5 lh-copy nested-copy-line-height"><p>最近少年PI的漂流很火，很少见的微博上一致的好评，可惜妹子正值考研的关键阶段，不好打扰。再加上自己经济上实在是拮据，也不想多给家里增添负担，只好作罢。至今为止有两部电影很想看却没看成，一部是它，另一部是阿凡达。当然，其中缘由大相径庭，谁叫生活变化这么快呢。</p><p>写东西，对我来讲是自身思维的整理，把我想的虑的形成文字表达出来。一个是我觉得自己最近的思路混乱，经常无法将一个问题描述清楚，逻辑上缺乏锻炼，或者也有可能是自己对问题本身并没有一个成型的思路。所以最近想把内心的东西挖出来，写点东西理一理，再次加工。</p><p>李安的电影我其实看的很少，小的是看过卧虎藏龙，后来读研的时候重新回顾了一遍。这个导演把每个镜头都拍的很美，很用心，在讲他想讲的东西，拍他想给我们看得东西，于是，整个片子中透露着一种美。真正的艺术家，不会去迎合大众，不会去矫揉造作，他应该做他自己，展现出他想展现的，不带名利的枷锁，这样的作品中自然透露着一种美。请允许我不断的用美这个词汇，因为我词穷。当一个艺术家在创作时不是往自己的内心挖掘，而开始在意外界的元素时，比如名利，就是他艺术消亡的开始。</p></div></div></div></div></section><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/page/2/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item active"><a aria-current=page aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/posts/page/4/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/4/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://whbzju.github.io/>&copy; Wujia Blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>