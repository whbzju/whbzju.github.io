<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Wujia's Blog</title><link>https://whbzju.github.io/posts/</link><description>Recent content in Posts on Wujia's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 06 Oct 2022 15:33:57 +0800</lastBuildDate><atom:link href="https://whbzju.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>不一样的论文解读：2018 Real Time Personalization Using Embeddings for Search Ranking at Airbnb</title><link>https://whbzju.github.io/posts/2018-real-time-personalization-using-embeddings-for-search-ranking-at-airbnb/</link><pubDate>Thu, 06 Oct 2022 15:33:57 +0800</pubDate><guid>https://whbzju.github.io/posts/2018-real-time-personalization-using-embeddings-for-search-ranking-at-airbnb/</guid><description>Airbnb这篇论文拿了今年KDD best paper，和16年google的W&amp;amp;D类似，并不fancy，但非常practicable，值得一读。可喜的是，据我所知，国内一线团队的实践水平并不比论文中描述的差，而且就是W&amp;amp;D，国内也有团队在论文没有出来之前就做出了类似的结果，可见在推荐这样的场景，大家在一个水平线上。希望未来国内的公司，也发一些真正实用的paper，不一定非要去发听起来fancy的。
自从Word2vec出来后，迅速应用到各个领域中，夸张一点描述，万物皆可embedding。在NLP中，一个困难是如何描述词，传统有onehot、ngram等各种方式，但它们很难表达词与词之间的语义关系，简单来讲，即词之间的距离远近关系。我们把每个词的Embedding向量理解成它在这个词表空间的位置，即位置远近能描述哪些词相关，那些词不相关。
对于互联网场景，比如电商、新闻，同样的，我们很难找到一个合适表达让计算机理解这些实体的含义。传统的方式一般是给实体打标签，比如新闻中的娱乐、体育、八卦等等。且不说构建一个高质量标签体系的成本，就其实际效果来讲，只能算是乏善可陈。类似NLP，完全可以将商品本身或新闻本身当做一个需要embedding的实体。当我们应用embedding方案时，一般要面对下面几个问题：
希望Embedding表达什么，即选择哪一种方式构建语料 如何让Embedding向量学到东西 如何评估向量的效果 线上如何使用 下面我们结合论文的观点来回答上面问题，水平有限，如有错误，欢迎指出。
希望Embedding表达什么 前面我们提了Embedding向量最终能表达实体在某个空间里面的距离关系，但并没有讲这个空间是什么。在NLP领域，这个问题不需要回答，就是语义空间，由我们文明中的各式各样的文本语料组成。在其他场景中，以电商举例，我们会直接对商品ID做Embedding，其训练的语料来至于用户的行为日志，故这个空间是用户的兴趣点组成。行为日志的类型不同，表达的兴趣也不同，比如点击行为、购买行为，表达的用户兴趣不同。故商品Embedding向量最终的作用，是不同商品在用户兴趣空间中的位置表达。
很多同学花很多时间在尝试各种word2vec的变种上，其实不如花时间在语料构建的细节上。首先，语料要多，论文中提到他们用了800 million search clicks sessions，在我们尝试Embedding的实践中，语料至少要过了亿级别才会发挥作用。其次，session的定义很重要。word2vec在计算词向量时和它context关系非常大，用户行为日志不像文本语料，存在标点符合、段落等标识去区分词的上下文。
举个例子，假设我们用用户的点击行为当做语料，当我们拿到一个用户的历史点击行为时，比如是list(商品A, 商品B，商品C，商品D)，很有可能商品B是用户搜索了连衣裙后点的最后一个商品，而商品C是用户搜索了手机后点击的商品，如果我们不做区分，模型会认为B和C处以一个上下文。
具体的session定义要根据自身的业务诉求来，不存在标准答案，比如上面的例子，如果你要做用户跨兴趣点的变换表达，也是可以的，论文中给出了airbnb的规则：
A new session is started whenever there is a time gap of more than 30 minutes between two consecutive user clicks.
值得一提的是，论文中用点击行为代表短期兴趣和booking行为代表长期兴趣，分别构建Embedding向量。关于长短期兴趣，业界讨论很多，我的理解是长期兴趣更稳定，但直接用单个用户行为太稀疏了，无法直接训练，一般会先对用户做聚类再训练。
如何让Embedding向量学到东西 模型细节 一般情况下，我们直接用Word2vec，效果就挺好。论文作者根据Airbnb的业务特点，做了点改造，主要集中在目标函数的细节上，比较出彩。先来看一张图： 主要idea是增加一个global context，普通的word2vec在训练过程中，词的context是随着窗口滑动而变化，这个global context是不变的，原文描述如下：
Both are useful from the standpoint of capturing contextual similarity, however booked sessions can be used to adapt the optimization such that at each step we predict not only the neighboring clicked listings but the eventually booked listing as well.</description></item><item><title>Migrated Blog From Octopress to Hugo</title><link>https://whbzju.github.io/posts/migrated-blog-from-octopress-to-hugo/</link><pubDate>Thu, 06 Oct 2022 15:07:40 +0800</pubDate><guid>https://whbzju.github.io/posts/migrated-blog-from-octopress-to-hugo/</guid><description>自从社交媒体火起来后，很少用在blog写文章，这几年在知乎专栏写的比较多，收获了不少朋友，这个blog荒废多年。但鉴于社媒氛围的剧烈变化，还是blog这个老地方安静，后续会重启，作为一个自留地使用。
把域名买了后发现octopress已经是10年+前的事情，且早已经不维护, 准备迁移到hugo上，花了时间没有找到完美的迁移方式，多多少少会有些格式问题，后面慢慢修吧。好在这个blog的主要内容都是早期工作时间写的，内容质量一般，但也是自己成长的一部分，也懒得删掉了，对阅读起来体验不好的朋友道个歉。</description></item><item><title>微店引发的互联网模式思考</title><link>https://whbzju.github.io/posts/think-about-weidian-bussiness/</link><pubDate>Sat, 18 Apr 2015 20:48:00 +0800</pubDate><guid>https://whbzju.github.io/posts/think-about-weidian-bussiness/</guid><description>现有爆发的互联网模式，体现在将原先只有一小部分人能享受到的服务面向大众，从而实现对现有产业的改造。比如小米，原先苹果三星的价格导致大部分用户无法享受他们的产品。小米提供了一个相对优质的产品，牺牲了不少品质，比如外观、做工，但成功将价格定在大众可接受的区间，从而实现了爆发式的增长。这种例子，传统行业也有过很多例子，比如优衣库、Zara，将上流用户的衣服，通过降低一定的质量和设计，完成价格革命，让普通用户享受到时尚，从而实现服装行业的革命。相同的例子还有福特，将汽车面向普通大众。这些例子说明一个，在品质和价格间做好balance，将优质的服务面向大众，具有极大的潜力，同时也说明了一个行业趋向成熟。
回过头来仔细想下，为何苹果三星不直接面向大众提供服务。这里面除了品牌定位，还涉及到一个行业的发展。在行业发展初期，各种成本都是高昂的，所以只能面向一些高端用户。高端用户的定义可以是：对价格不敏感，但对品质有较高的要求。够用和追求品质是区分普通商品和奢侈品的重要区别，俗话说一分钱一分货，十分钱两分货。奢侈品对于人类有重要的意义，在这些no functional的地方持续的投入，恰是文明的来源。拉回来看前面的例子，若要将高端用户使用的服务面向大众，其品质必然会有所下降，但会进入一个处于可接受的范围，接着极力的压榨价格区间，进入市场后照成破坏性的增长，一家独霸。这里小米做到了，淘宝也做到了一半。
来看今天的主题&amp;mdash;微店，即微商。上面说到淘宝做到了一半，即对传统的零售商业模式的冲击并没有完成一家独霸，彻底改造。其原因在于，其商品价格下来后，优质的服务不能保证，即没有进入一个合理的区间。这里面的问题比较复杂，刨去假货不说，很多时候商品质量不好，真就是商家无法提供优质的服务。因为这些优质的服务被传统大佬们垄断着。淘宝可以抹除店面、分销的成本，但无法解决生产的问题，当这些大佬进入电商后，很快就被击垮。那为什么要提到微商，因为中国作为一个世界大工厂已经很多年，其生产能力在不断的提升，但缺少产品设计和分销渠道。而微商类似于，拥有这些资源的个人，不愿意被传统的渠道垄断，但有无法承担建立品牌的费用，借力与人与人直接的信任传播来实现分销。
这里重点讲下品牌，淘宝最大的问题还是在于流量越来越贵，小商户直接就出局了，没有办法顺利的进入成长期。而传统的大佬在建立品牌投入的巨大成本，需要靠一定的利润空间收回。所以，如果想打赢这场仗，必须抹除建立品牌的成本，而这也是微商可能能够提供的。天下没有免费得晚餐，如果不是某个环节的效率提高了导致价格的下降，这种模式是不可持续的。这也是为什么目前微商中的代购、面膜之类的东西不能长远的原因。从这点来看当前几个比较热的互联网公司，能得到一定的启示。拨开热闹的表象，观察其是否能照成流程或生产力的提高。比如小米最近的装修，就是一个极好的商业切入点，非常值得资本进入烧钱。同样的还有快的和滴滴。
最后，互联网模式有个重要的特点，即scalable&amp;mdash;即高度可复制性，这点下次再讨论。</description></item><item><title>Kaggle入门总结</title><link>https://whbzju.github.io/posts/kaggle-bike/</link><pubDate>Sat, 18 Apr 2015 20:38:00 +0800</pubDate><guid>https://whbzju.github.io/posts/kaggle-bike/</guid><description>在知乎上看过一个答案，大意是有个地方叫kaggle，推荐搞机器学习的同学多上去撸一撸，实践出真知。同时还建议先把101系列的题目撸完，再选个感兴趣的比赛做。该答案详情见参考文献。
工具 有工程背景的同学，建议python，拥有不输给R的生态。主要用到以下工具：
ipython notebook + pandas + sklearn 在面对特别大的数据集，使用了公司的spark。
ipython notebook，神器，请参考我的另一篇blog Ipython Notebook对机器学习工程师的价值 pandas: 从工程过来的同学，首先请放弃循环之类的代码实现方式，拥抱dataframe。 sklearn：在github上非常活跃的项目，请多读官方文档。 spark：一般kaggle上比赛的数据量级是没有必要用它，但是最近有个比赛train的数据上百g了，所以试了下它。 比赛选择 首先，请从101系列中选几个做做，该系列一般有详细的教程，熟悉kaggle。接着选几个正在进行的比赛练手。一开始别贪心，注意下数据集的大小，当数据集大于几个g后，工程相关的工作会增加很多，同时对单机的性能有一定的要求，不利于初学者。但是，数据量大更符合真实的情况，比如做过一个ctr预估的比赛，无论是特征工程和模型训练都要更小心谨慎，每次试错的成本很高，随便训练一个模型都需要3-4小时，相应的这个比赛让我意思到sample的重要性，以及一个非常重要的特征处理方法featrue hashing.
本文将重点总结我在做自行车出租数量预测这个比赛的情况。该比赛介绍如下：
You are provided hourly rental data spanning two years. For this competition, the training set is comprised of the first 19 days of each month, while the test set is the 20th to the end of the month. You must predict the total count of bikes rented during each hour covered by the test set, using only information available prior to the rental period.</description></item><item><title>random forest</title><link>https://whbzju.github.io/posts/random-forest/</link><pubDate>Mon, 16 Feb 2015 15:09:00 +0800</pubDate><guid>https://whbzju.github.io/posts/random-forest/</guid><description>概述 知识背景要求 本文要求读者对机器学习中的一些基本概念有一定了解，比如特征，交叉验证，generation等概念。随机森林基于决策树模型，读者事先最好对决策树有一定的了解，若完全不了解，请将文中的tree抽象成能告诉你对错的一个black box，则不会影响理解。
目录 基本思想 理论保证 实践中常用的特性 实践效果验证 需要重点注意的 参考 基本思想 Ensemble method ensemble是当前主流机器学习领域一个非常流行的概念。引用sklearn的文档：
The goal of ensemble methods is to combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator.
其又分为两大类：averaging和boosting，分别以Random Forest和AdaBoost算法为代表。
Random Forest 引用wiki的定义：
Random forests are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees.</description></item><item><title>机器学习技巧之feature_hashing</title><link>https://whbzju.github.io/posts/feature-hashing/</link><pubDate>Tue, 10 Feb 2015 15:58:00 +0800</pubDate><guid>https://whbzju.github.io/posts/feature-hashing/</guid><description>问题 最近在玩kaggle上的ctr比赛，其训练数据含大量categorical，无法直接用LR模型。举个例子，某个categorical数据集含[苹果，西瓜，梨，桃子]四个类别，一般的处理方法是将这些类别映射成[0,1,2,3]，放入模型中训练。其实这是不合理的，在categorical中，桃子和西瓜并不存在等级差，而变成[1,3]后会存在3&amp;gt;1的问题。以Logistic Regression为代表的算法就无法对该特征学到合适的参数。因此，业界一般会对categorical数据集做onehotencoding，即向量化，还是以上面数据为例子，苹果对应的向量为[1,0,0,0]，桃子对应的为[0,0,0,1]。在sklearn中，可以通过OneHotEncoding或get_dummies实现。显而易见，数据会变得非常稀疏。同时，当categorical的类别变多，特征维度随之剧增，带来的内存存储问题。比如在这次的ctr中，如果采用OneHotEncoding，我60g内存的机器也会报Memory error。
再次，ctr领域或者说高维大数据领域，数据集或多或少的存在稀疏问题。主流ML库都会实现一套稀疏矩阵，应对该问题。feature hashing又称feature trick，类似于kernel trick，在ML领域得到广泛应用的技巧。 维基上的定义：
In machine learning, feature hashing, also known as the hashing trick[1] (by analogy to the kernel trick), is a fast and space-efficient way of vectorizing features, i.e. turning arbitrary features into indices in a vector or matrix. It works by applying a hash function to the features and using their hash values as indices directly, rather than looking the indices up in an associative array</description></item><item><title>git 实践</title><link>https://whbzju.github.io/posts/git-practices/</link><pubDate>Sat, 07 Feb 2015 08:54:00 +0800</pubDate><guid>https://whbzju.github.io/posts/git-practices/</guid><description>git rebase和git branch svn过来的同学一定会觉得git的分支管理好方便，但更应该了解的是git rebase。可以说，用不用git rebase是区分你熟不熟悉git的重要方式。
##git reset
git fetch和git pull git commit -amend</description></item><item><title>2014读过的书和参加的公开课</title><link>https://whbzju.github.io/posts/2014-readlist/</link><pubDate>Fri, 02 Jan 2015 10:45:00 +0800</pubDate><guid>https://whbzju.github.io/posts/2014-readlist/</guid><description>技术类 机器学习 Pattern Recognizition and Machine Learning. 目前完成前四章，还没有完全吸收，希望2015的成长能够顺利吸收这本书的知识。 推荐系统cookbook。感觉这本书有些落后于时代，大致翻了下。 推荐系统实践&amp;ndash;项亮。入门好读物。 Frontiers in Massive Data Analysis。综述型，推荐。 The Elements of Statistical Learning : Data Mining, Inference, andPrediction。当做工具书，还没有读多少，先把PRML搞定。 kaggle solution分享。 Python python cookbook. 非常推荐。 廖雪峰的python教程. 简洁概要，实战内容有难度，很适合提供自己编程水平。 python for data analysis。了解到pandas，数据分析利器。 sklearn官方文档。图文并茂，极力推荐。 pandas官方文档。例子丰富，入门先推荐10min那篇。 R 粗略看了写文档。
非技术类 文明之光（上下），推荐，吴军博士的书质量一如既往。 女士品茶。概率论发展史及大牛八卦。 英语语法俱乐部&amp;ndash;施元佑。大力推荐，介绍语法的来龙去脉。以前太不看重语法，阅读和写作的瓶颈。 金字塔原理。 思考的艺术 如何阅读一本书 数理统计简史 公开课 Andrew Ng的Machine Learing。完成 台大的机器学习基石。完成 Functional Programming Principles in Scala。继续上 Mining Massive Datasets，正在上 機器學習技法 (Machine Learning Techniques)。正在上 互联网资讯 咨询：依旧是知乎，目前没有看到什么能替代。 kaggle，非常好的机器学习学习平台 cousera，2015能学更多有价值的课程。</description></item><item><title>机器学习基石课程总结</title><link>https://whbzju.github.io/posts/about-ml-fundation-course/</link><pubDate>Sun, 28 Dec 2014 11:07:00 +0800</pubDate><guid>https://whbzju.github.io/posts/about-ml-fundation-course/</guid><description>课程一开始，提了四个topic，what every machine learning user should know
* when can ml learn * why can ml learn * how can ml learn * how can ml learn better When can ml learn 首先，机器学习针对的场景，通过A对D和H学习一个g，用来描述最终的目标f，而这个事情无法简单的用规则搞定。其次，澄清各类细分ml场景的定义：
* 监督式 * 非监督式 * 增强学习 * 推进系统 * Activity学习，通过asking来学习 * Streaming why can ml learn * shatter的概念 * break point的概念 * generation问题 * VC维的概念 how can ml learn 讲了一些基本的linear方法，比如logistic regression，顺便提了下nonlinear的问题，通过transform将nonlinear映射到linear可分的空间，有点类似核函数，需要进一步确认。
how can ml learn better * overfiting * regularition，这块数学不错。从拉格朗日的constraint说起，到L1和L2的直观意义。 * cv * 三个重要的Principle。Occam's Razor， Sample Bias， Data Snooping.</description></item><item><title>记第七届R语言大会</title><link>https://whbzju.github.io/posts/r-language-conference/</link><pubDate>Sun, 30 Nov 2014 11:01:00 +0800</pubDate><guid>https://whbzju.github.io/posts/r-language-conference/</guid><description>这届R语言大会在杭师仓前校区举行，由阿里巴巴承办。邀请到了libsvm的作者林老师。但据同事说林教授演讲用的ppt都是一套（汗~~~）。上午是主会场，有四位嘉宾做了介绍，其他几位介绍的比较范，林稍微带点干货，特别提到数据没有到20T，不一定要上big data。下午是分会场，本人去听了：
分析师使用的R包 京东的ctr模型 天猫learning to rank 天猫数据驱动运营。 点评 京东分享推荐的ctr模型。和我街处于同一起跑线，模型和特征做法都很相似。赞下京东的分享着，讲的很实在。 天猫l2r。没什么干货，介绍了一些基本概念就结束了。 天猫数据驱动运营。预测销量，c2b。介绍的比较范，而且个人觉得他讲的效果有夸大的嫌疑。 分析师用的R包。R中类似ipython notebook的东西。可交互的图，非常实用。 感想 Spark出现的频率很高。 用R来作云服务，我个人觉得不靠谱。 libsvm的作者好有趣。演讲前看论文，演讲后睡觉。工业界范十足。 学术界的分享依旧不靠谱。 IBM关于电信领域的挖掘是来搞笑的吗 接下来就等ppt了。 最后，和阿里比，其他公司的所处的阶段还是非常的初级。</description></item><item><title>ipython notebook对机器学习工程师的价值</title><link>https://whbzju.github.io/posts/ipython-notebook-bring-to-me/</link><pubDate>Sun, 23 Nov 2014 16:17:00 +0800</pubDate><guid>https://whbzju.github.io/posts/ipython-notebook-bring-to-me/</guid><description>关键词：代码、数据、文档合一。
&amp;mdash;-draft: false toc: true 如果选一个关键词来描述机器学习工程师的工作，不断试错是我心中的number one。相对于软件工程师来讲，有大量琐碎的dirty需要做，通常会占据到80%左右的时间。一个好的工具能够极大的提高效率。
总结需求如下：
可交互式的环境：比如预处理数据，有的时候数据比较大，比较耗时，希望能处理一次后就放在内存里面使用。 文档化，记录工作流。数据挖掘会有非常多的idea要去尝试，实现这些idea的代码会有微小的差异，需要一个工具能够统一追踪管理他们。且不同的实验会有不同的结果，整理这些结果形成文档太费时间，希望能够做完实验就生成文档。 经常会有一些片段代码要写，写在文件里有太零碎，写在交互式的shell里面有很难回溯，需要一个交互式和文档结合的工具。 支持可视化工具，兼容python画图 神奇的ipython notebook 安装环境 非常简单，推荐：Anaconda, 官网
ipython notebook入门 还是官网, 一开始不适应的同学，多看几个example吧。
分享你的ipython notebook 一键分享：A simple way to share Jupyter Notebooks
最后 附一张我的在kaggle上用ipython notebook做的一个入门题照：</description></item><item><title>聚类算法中常见的距离计算方法</title><link>https://whbzju.github.io/posts/ml-distance-measure/</link><pubDate>Sat, 22 Nov 2014 22:01:00 +0800</pubDate><guid>https://whbzju.github.io/posts/ml-distance-measure/</guid><description>概述 在面对聚类问题时，选择何种距离计算方法求相似度是一个basic question。文献[1]中提到了N多计算方法，从大类来看有以下几种：
$L_p$ Minkowski家族 $ L_1 $ 家族 Intersection 家族 Inner Product家族 etl 简单算一下大概有40+个计算方法，其中有好多没有听过。好在工业界一般只涉及到几个，本文将按自己理解大致介绍下这些方法及应用情况。 距离的类型和尺度 类型：
二进制（binary） 离散值（Discrete） 连续值(Continuous) 尺度：
定性：比如同义：red、green、black，比如顺序：高、中、低 定量： a) interval b) ratio 距离的类型和尺度非常重要，影响后续聚类算法的选择。 距离计算方法定义 严谨的定义参考[4]，通俗来讲，在一个空间内，距离计算方法满足以下4个公理。
$d(x,y) ≥ 0$ $ d(x,y)=0$ if $x=y$ $ d(x, y) = d(y, x)$ (distance is symmetric) $d(x, y) ≤ d(x, z) + d(z, y)$ (the triangle inequality). 在欧式空间，第四个公理可以直观理解为两点之间距离最短。在其他情况需要一些证明才能推导。
常见的距离计算方法 Lr norm 在n维空间，其计算公式如下：
$d(x,y)=(\sum_{k=1}^{n} |x_k-y_k| ^r)^{1/r}$
欧式距离 当r=2，这就是我们熟悉的欧式距离，其聚类形状在二维空间是一个圆。归属于$L_2$ norm
曼哈顿距离 r=1，归属于$L_1$ norm，其名字的来源与该距离计算过程有关。该距离类似在x和y的每个维度上沿grid line上travel，类似曼哈顿的街道。</description></item><item><title>Coursera上Andrew Ng的机器学习课程评价</title><link>https://whbzju.github.io/posts/machine-learning-at-coursera/</link><pubDate>Sat, 13 Sep 2014 21:49:00 +0800</pubDate><guid>https://whbzju.github.io/posts/machine-learning-at-coursera/</guid><description>前言 该课程非常适合初学者，比原先Ng在斯坦福大学的公开课要简单许多，少去了许多数学，并且在课程内容安排上更加紧凑，涉及的内容广泛，旨在搭建初学者与机器学习的桥梁。值得一提的是，该课程较为接近工程的角度，故我建议有兴趣的工程师可以尝试下。
本人花了3周左右的时间完成了该课程的视频和project，并拿到证书。每天下班回来比较晚，倒腾一两个小时，就该洗洗睡了，还好妹子理解。但不建议初学者像我一样，原因如下：
本人有一定的机器学习基础。 虽然不熟悉octave，但是写过几年程序，能较快的适应它的语法。 该课程没有中文字幕，不过Andrew Ng将的英文都比较简单，大家可以放心，我一般加速1.5x听。 该课程有个较为合理的时间预估，可根据它安排学习计划。
内容介绍 建议先看视频 Ng的视频和ppt做的非常有质量，简洁易懂。该课程有19个课程，每个课程一般有4-6个小视频，视频时间有长有短，最长的不会超过20分钟。下面列下个人觉得最有价值的部分：
Octave Tutorial，该教程能够帮你快速了解octave的基本用法，后续所有的project都会涉及到它。请对照该课程的讲义熟悉octave。PS：mac上安装octave可能会出些问题，我这边只要取消安装text help部分即可。 主流算法，Logistic回归，SVM，ANN，Kmeans，PCA，协同过滤等，可以理解为通俗易懂版的讲解，不满足的同学建议去看看Ng在斯坦福公开课中的视频，那边会有较详细的数学推导。 最为精华，即本人认为该课程最核心的部分是：X. Advice for Applying Machine Learning (Week 6)和XVIII. Application Example: Photo OCR。因为其他知识很容易得到，而且可以得到更好更完备的解释，而这两个视频，是Ng从工程的角度指导我们如何应用机器学习，并且给了一个实际的例子。 建议完成所有课程的project 由于这些project的说明文档写的非常仔细，较为容易完成。通过写一些代码，可以对这些算法有更深的理解。另外，也可以认识到octave vectorizing写法的威力。
PS：请不要着急去网上搜课程答案，Ng在课程里面明确说明不要把作业答案放到网上，但还是有不少人放了自己的答案。提前看了答案，你会少很多乐趣。
draft: false toc: true 总结 后来也看了几个coursera上的课程，暂时还么有找到能和它一拚的课程。如果有哪位同学知道，可以分享下。 当然，这个课程只是个开始，后续可以看斯坦福大学的机器学习课程，同时配合Pattern Recognized and Machine Learning这本书效果会更好。</description></item><item><title>Markdown_gramma(转)</title><link>https://whbzju.github.io/posts/markdown-gramma/</link><pubDate>Tue, 08 Apr 2014 22:46:00 +0800</pubDate><guid>https://whbzju.github.io/posts/markdown-gramma/</guid><description>个人收藏用，转：&amp;laquo; 访问 Wow!Ubuntu
NOTE: This is Simplelified Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax.
声明： 这份文档派生(fork)于繁体中文版，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里查看它的源文件。「繁体中文版的原始文件可以查看这里 。」&amp;ndash;By @riku
注： 本项目托管于 GitCafe上，请通过&amp;quot;派生&amp;quot;和&amp;quot;合并请求&amp;quot;来帮忙改进本项目。
Markdown 语法说明 (简体中文版) / (点击查看快速入门) 概述 宗旨 兼容 HTML 特殊字符自动转换 区块元素 段落和换行 标题 区块引用 列表 代码区块 分隔线 区段元素 链接 强调 代码 图片 其它 反斜杠 自动链接 感谢 Markdown 免费编辑器 Markdown 的目标是实现「易读易写」。
可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 [Setext] 1、[atx] 2、[Textile] 3、[reStructuredText] 4、[Grutatext] 5 和 [EtText] 6，而最大灵感来源其实是纯文本电子邮件的格式。</description></item><item><title>Vim tips</title><link>https://whbzju.github.io/posts/vim-tips/</link><pubDate>Mon, 07 Apr 2014 10:00:00 +0800</pubDate><guid>https://whbzju.github.io/posts/vim-tips/</guid><description>收集我个人学习使用Vim的小技巧
##快速替换##
语法: [addr]s/源字符串/目的字符串/[option] [addr] 表示检索范围，省略时表示当前行。如： “1，20” ：表示从第1行到20行； “%” ：表示整个文件，同“1,$”； “. ,$” ：从当前行到文件尾； s：正则表达式中替换命令 [option] : 表示操作类型 g 表示全局替换; c 表示进行确认 p 表示替代结果逐行显示（Ctrl + L恢复屏幕） i 不区分大小写 省略option时仅对每行第一个匹配串进行替换； 如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义 例子：将多个空格换成一个空格: %s/ */ /g
##多文件打开 打开：split file
切换窗口：双击ctrl+w，或ctrl+w+上下左右键</description></item><item><title>Windows tips</title><link>https://whbzju.github.io/posts/windows-tips/</link><pubDate>Mon, 07 Apr 2014 10:00:00 +0800</pubDate><guid>https://whbzju.github.io/posts/windows-tips/</guid><description/></item><item><title>Ubuntu tips</title><link>https://whbzju.github.io/posts/ubuntu-tips/</link><pubDate>Mon, 07 Apr 2014 09:59:00 +0800</pubDate><guid>https://whbzju.github.io/posts/ubuntu-tips/</guid><description/></item><item><title>introduction to android adb</title><link>https://whbzju.github.io/posts/introduction-to-android-adb/</link><pubDate>Sun, 30 Mar 2014 12:23:00 +0800</pubDate><guid>https://whbzju.github.io/posts/introduction-to-android-adb/</guid><description>Recently, I&amp;rsquo;m interesting how android adb works. If you are an Android programer, you certainly familiar with adb shell,adb logcat. Or maybe you only use eclipse, it is helpful to know behind DDMS there is adb.
#ADB overview We can find adb description from android developer website.
Android Debug Bridge (adb) is a versatile command line tool that lets you communicate with an emulator instance or connected Android-powered device. It is a client-server program that includes three components:</description></item><item><title>2013年读过的书</title><link>https://whbzju.github.io/posts/2013dushu/</link><pubDate>Sun, 12 Jan 2014 23:09:00 +0800</pubDate><guid>https://whbzju.github.io/posts/2013dushu/</guid><description>##技术类
###C++
esstianl c++，大学的时候读过，忘的差不多了。这次项目用到c++，为了快速上手，重读了一遍。评价五星。 c++ prime。至今还没有通读，处于当手册使用的阶段，书中的例子很赞，可以作为c++ cookbook。 effective c++。强烈推荐，不解释。 effective stl，因为effective c++才买的，看了感觉和上一本的级别差太多，不推荐。 这里推荐c++ reference这个网站，有很多优秀例子代码，是很好的参考对象。同时，该网站支持在线编译运行，很赞。
###C
C专家编程。很赞，为它写了一篇简单的博客。 ###Android
深入Android源码分析，卷一，邓平凡。强烈推荐，作者功力深厚，庖丁解牛。目前通读一遍，对JNI、Binder通信的理解加深许多。而像SurfaceFlinge这样的系统还没有很好的理解。 深入Android源码分析，卷二，同。 ###机器学习
斯坦福大学机器学习课程及讲义。入门的好材料。 集体智慧编程。基于Python的机器学习常见算法教程。 ###代码质量、设计
设计模式。GOF的，看一遍，感觉理解了，很快又会忘掉不少，每次做完项目重新看，都会有收获。 google开源编程规范。 ###其他
自己动手实现操作系统。 深入理解C# effective Java ##非技术
德川家康&amp;mdash;长篇推荐，感慨日本人名字的神奇 冰与火之歌&amp;mdash;魔龙狂舞，马丁爷爷一定要长命百岁 浪潮之巅&amp;mdash;-推荐 活着活着就老了，冯唐 小通鉴，冯唐 人为什么活着，王小波 地久天长，王小波 走出软件磨坊 精益创业 创业四步法 PS：今年上的最多的网站是知乎，感谢各位大牛热心分享知识。</description></item><item><title>Mac OS 10.9 安装scikit--万恶的墙</title><link>https://whbzju.github.io/posts/wanerdeqiangheanzhuangscikit/</link><pubDate>Sun, 29 Dec 2013 14:26:00 +0800</pubDate><guid>https://whbzju.github.io/posts/wanerdeqiangheanzhuangscikit/</guid><description>##前言
工作以来，接触不少机器学习相关的知识，一直听说python在这方面有许多优秀的工具，顺便自己也想学习python。经google后，决定安装scikit-learn试试。在官网上找到安装教程后，开心的发现支持brew。 安装教程
悲剧从此发生。。。brew需要安装的源许多都在SourceForge上，但是该网站被天朝强大的“墙”屏蔽了。没有办法一键安装。
##源码安装 我也很纳闷为什么brew的源大部分在SourceForge上，为何不用GitHub的。既然不能一键安装，那我通过源码安装总可以吧。 scikit需要numpy和scipy两个重要的组件，在scipy官网找到安装教程.
在安装scipy的提示
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/lipo: can't open input file: 在查阅了一些资料后，问题貌似是由于xcode 5版本和xcode 4在工具链上有不少调整导致的，试了几种方法后未能解决。
##brew 撞墙怎么办 参考网上资料，只有自己把文件下好，放到 /Library/Caches/Homebrew/ ，但是如果文件很多，就悲剧了。
##不要轻易更新系统 在解决了brew撞墙问题后，继续尝试brew安装，依旧没有成功，提示xcode5版本太新，
make: *** [bootstrap] Error 2 Error: Homebrew doesn't know what compiler versions ship with your version of Xcode (5.0.2). ##未完待续</description></item><item><title>如何在手机上实现高精度及自适应多种场景的计步器算法</title><link>https://whbzju.github.io/posts/pedometer/</link><pubDate>Fri, 27 Dec 2013 22:58:00 +0800</pubDate><guid>https://whbzju.github.io/posts/pedometer/</guid><description>#前言 随着当前智能终端的普及，人们可做的事情变得越来越有趣，比如计步器。传统的计步器一般是一个单独的设备，戴在身体的某个位置，由于必须在用户身上增加一个设备，推广起来有一定阻力。其实，计步器只需要一个3-轴加速度传感器就能做到较高的记步精度，类似三星note3的计步器精度在95%以上。当前智能手机一般都含有加速度传感器，许多人开始在手机上做计步器。可惜目前Android市场上大多数计步器精度都不理想，经本人测试，目前最好的是三星的note3的健康伙伴，更关键的是三星使用了sensorhub的技术，在保持精度的同时，做到了超低功耗。 在手机上做计步器相较于传统的计步器最大的难点在于手机使用时位置不固定，计步器要能适应不同放置位置和不同走路场景，这就要求计步器算法有很好的动态调整能力。
#计步器模型介绍 关于人走路的模型，前人[1]已经做了很多研究，不再累赘。总结来讲，人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：
#算法
##概述
特征选取 滤波 基于动态阈值检测步数 步数矫正 ##特征选取 考虑到手机在不同放置情况下传感器的每个轴会有不同表现，因此，取其强度特征可以避免该类问题，即取三轴平方和。
##滤波 滤波是一种常见的数据预处理方法，特别是手机上加速度传感器数据存在一定的噪音，经过滤波后能得到较平滑的数据。滤波算法有许多中，常见的有数字滤波，也可以叫中值滤波、高斯滤波、快速傅里叶变换。本人试过几种滤波算法后，发现采用中值滤波即可满足需求，因为算法的瓶颈并不在此。另一个考虑是终端的计算资源有限，过多的计算将造成大量的耗电。
简单来讲，即取一个时间窗做平滑，假设以50HZ的频率采集加速度传感器数值，即在Android中注册Sensor频率为Fastest（不同手机可能会有差异）。我采用5个数据做一次平滑，即收到5个数据算一次平均值，当做当前值。当然，你可以增加时间窗长度，但是需要考虑用户体验，不能延迟太久。
##动态阈值 通常，计步器有两种思路：一种是通过计算过零率来记步；另外一种是计算极大值和极小值，判断峰谷值来记步。两种算法的思想类似，都需要设置阈值。为了适应各种不同的位置和走路姿势，你不能简单设一个阈值来检测步数。第一种方法容易出现误记，需要结合其他方法排除在mean值附近抖动的数据。第二种方法容易出现漏检，同时如果误记，还会影响到后续的记步，因为在一次步伐中出现好几个峰谷是很正常的，如何去除这些数据的影响需要良好的设计。
本人采用的检测峰谷值得方法记步，但不是通过计算极大值和极小值，而是设置波峰的阈值和波谷的阈值，即当数据大于波峰阈值时，都记为未确认峰值，保存其中最大的一个，这样可以避免数据在上升途中偶尔出现的抖动。同理，作用于峰谷。 检测出峰谷之后，通过保存一个时间窗，通过里面的峰谷个数记步。这里更多的是工程上的设计。
##步数矫正 基本思想是人类走路的特性，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔&amp;lt;200ms和&amp;gt;2000ms，认为是无效步数。这部分也是目前终端计步器算法的核心，做的好的公司都有相应的矫正机制。
#总结 计步器算法的基本思想大致如此，最终产品的表现还要不断打磨，针对异常场景进行优化。最后，终端设备上应用不可避免的是功耗问题，如果开了计步器，你的手机用半天就没电，估计没人愿意用。目前市场上许多低功耗计步器算法，大多以降低精度为代价。目前看来只有三星采用高通的sensorhub方案有较好的表现。
参考：
[1] 利用3轴数字加速度计实现功能全面的计步器设计
[2] Github上的一个计步器实现代码 改代码直接使用效果不好</description></item><item><title>编程小扎之回调</title><link>https://whbzju.github.io/posts/bianchengzhihuidiao/</link><pubDate>Fri, 20 Sep 2013 14:49:00 +0800</pubDate><guid>https://whbzju.github.io/posts/bianchengzhihuidiao/</guid><description>在我的认知中，编程最需要要关心的是数据结构和消息机制。进一步，即模块功能的定义，以及模块之间的通信。这和编程中的回调机制十分类似。回调在wiki中有如下定义：
In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback. The ways that callbacks are supported in programming languages differ, but they are often implemented with subroutines, lambda expressions, blocks, or function pointers.</description></item><item><title>C专家编程摘要</title><link>https://whbzju.github.io/posts/c-yuyuan/</link><pubDate>Thu, 19 Sep 2013 23:27:00 +0800</pubDate><guid>https://whbzju.github.io/posts/c-yuyuan/</guid><description>上个月经人推荐，看了这本《C专家编程》，大赞，推荐用C的人都去看看。除了能从历史上了解 C语言的一些语法，还能学到一些常用规范。特别是指针和数组部分，很有收获。 用一张思维导向图总结</description></item><item><title>人脸识别实践总结</title><link>https://whbzju.github.io/posts/renlianshibiezongjie/</link><pubDate>Sun, 28 Jul 2013 10:06:00 +0800</pubDate><guid>https://whbzju.github.io/posts/renlianshibiezongjie/</guid><description>#概述 前段时间接触了一阵子人脸识别，只能说是初窥门道，在这里做个总结。本文不涉及具体的算法原理，因为我都是参考别人的资料，只认为无法写的更好，在这边做个归纳总结。 现需求如下：从摄像头视频中识别出你自己或朋友的人脸
要实现这个需求，大体分为两个步骤，分别为人脸检测和人脸识别，即先要从摄像头中识别出人脸，即人脸检测，其次对检测到的人脸进行识别，即人脸识别。本文基于Opencv的人脸算法实现。
##人脸检测流程
选取特征（本文采用Haar-like特征） 选取分类器算法，训练人脸分类器（本文采用Adaboost级联分类器） 对图像进行人脸检测 ##人脸识别流程
选取人脸识别算法（本文包括PCA、FDA和LBP） 训练识别模型 对目标进行识别 #Opencv相关资料介绍 opencv在2.4后引入了人脸识别相关模块，原来只有人脸检测部分。在Opencv官网，有较详细的介绍，看 !目录，在该目录中重点要看这篇!Face Recognition with OpenCV.
这应该是一个德国人写的，在教程中他提到了3个算法：
EigenFaces FisherFace Local Binary Patterns Histograms 前面两个算法都是利用子空间的原理，有一定的相似性，分别以PCA和LDA为基础。后者以特征选取为主，做法思路都不大一样，建议分开看。该教程中对算法的描述过于简洁，不适合初学者看，建议寻找相关资料进一步阅读。 ##PCA-主成分分析法 PCA在很多地方都有应用，是一个十分简单有效的方法。其思想概括起来即降维，它认为原始数据中包含了大量的噪音和冗余，通过协方差矩阵的对角化可以得到一个子空间，该子空间的维度大大降低，却神奇的保留了原始数据中的显著特征。
该算法的具体原理可参考斯坦福大学的公开课，Andrew.Ng的机器学习课程，里面有一章节专门讲pca，若觉得看视频太慢，可以直接看讲义，讲的很清楚。国内有几个博客作者对它进行了翻译，推荐：
!主成分分析（Principal components analysis）-最大方差解释
!机器学习中的数学(4)-线性判别分析（LDA）, 主成分分析(PCA)
该算法涉及较多的线性代数知识，忘掉的同学建议复习下相关内容。
##LDA-线性判别分析 fisherface的FDA是在LDA基础之上的一种算法。关于线性判别的思想如下：它认为在PCA中，PCA把数据作为一个整体来看，即数据源中所有的显著特征都会被保留下来，如果一个人的脸在强光下和弱光下，pca生成的子空间有显著的差异，而他们却是同一张脸。LDA的思想是寻找一个分割平面（在二维中即直线），来区分两种不同类别的数据，既能够区分两个不同的人脸，进行归类。因此，它的目标就是怎么要找到这个平面，达到最好的区分效果。
同样，该算法的具体原理还是推荐Andrew.Ng的机器学习公开课。国内也有相关介绍，但是他们的数学推导让我不满意。
!线性判别分析（Linear Discriminant Analysis）（一） !线性判别分析（Linear Discriminant Analysis）（二）
##LBPH 该算法较上面二者容易理解，这里不做详细介绍，大家自己查找相关资料即可。
##Demo 上面教程中提到几个算法opencv中都有例子实现，当然要做2.4以上。教程讲了demo的位置和具体的使用。 所有的Demo需要一个人脸库，教程中提供了几个，可以下载。下载下来的人脸库需要预处理，即打上标签，作者提供了python脚步，大家可以使用。
有个demo值得关注，它实现了我们的需求，它有个专门的教程：!Face Recognition in Videos with OpenCV. 不过要想识别自己的脸，必须将自己的脸裁剪下来保存到人脸库中进行训练。
我不想自己拍照片去裁剪，我的做法是利用demo中的人脸检测算法，将我的人脸检测到，然后保存成灰度图，放到人脸库中。PS：这里有个问题，opencv自带的人脸检测分类器有可能会误捡，会把空白的墙壁当做人脸。我的做法是，在视频中指定一个矩形框，在这个矩形框中进行人脸检测，这样可以大大降低误捡率。实际操作中可以调整位置，让自己的人脸出现在矩形框中。
#Haar-like特征Adaboost级联分类器 完成了人脸识别的Demo验证，大家一定很好奇人脸检测是怎么实现的。opencv里面自带的检测算法原至两篇论文： P. Viola and M. Jones. Rapid object detection using a boosted cascade of simple features.</description></item><item><title>浅析JNI（三）</title><link>https://whbzju.github.io/posts/qianxi-jni-3/</link><pubDate>Sat, 27 Jul 2013 22:41:00 +0800</pubDate><guid>https://whbzju.github.io/posts/qianxi-jni-3/</guid><description>没想到这个话题写到第三篇博客，写blog真费时，我的周末没了。接上文继续： PS更新:这篇blog一拖就是一个月，主要是我太懒了。其次是在公司写的东西不能带出来，每次要写这方面的资料，必须重写一些demo进行说明，重复劳动，没有动力。
#内容概述
JNI数据类型 JNIEnv介绍 ##JNI数据类型介绍
基本数据类型 先来看一张图： 可以明显的看出JNI的数据类型只是比java的基本数据类型多了个j。
引用数据类型 同样看图： 可以看出所有的引用类型都是jobject，和java类似。不过jni里面对jstring单独做了处理，就叫jstring类型，估计是用的频率太高，如果也是jobject会涉及到大量的“装箱拆箱“吧。
##JNIEnv介绍 JNIEnv是jni中举足轻重的一个角色，env可以理解成window中的句柄，线程中的线程描述符，或者简单理解成当前的上下文环境变量。在java VM中，它是一个局部引用，因此无法作为全局引用保存下来，每次在jni调用时，都要重新获取下env，因为env有可能会发生变化。
##实例讲解&amp;ndash;Jni回调java 在工作中，我们使用jni时，常常会碰到需要从native回调java的需求，比如java通过jni调用native的一些函数，如果这些函数较为耗时，经常会起一个线程来完成任务，那么当任务完成时，必然要告诉java层。通常的做法是java层通过jni设置回调函数，native通过jni回调java。先看代码：
public class jniActivity extends Activity {
private TextView tv; //private String test; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); SetJniCallBack(); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // Java通过该方法设置回调方法 public native void SetJniCallBack(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.</description></item><item><title>转：公开课点评（收藏用）</title><link>https://whbzju.github.io/posts/gongkaikedianpian/</link><pubDate>Mon, 01 Jul 2013 22:30:00 +0800</pubDate><guid>https://whbzju.github.io/posts/gongkaikedianpian/</guid><description>#原文 !链接
今天在图灵Q群里聊到一些公开课心得。群友隋春宁建议我总结一下、发到社区。我也觉得这些信息可能对公开课同好有帮助，遂总结如下：
我觉得比较好的课程：
Algorithms: Design and Analysis, Part 1 和 Part2 都挺好的，算是理论和实践结合得很好、难度介于入门和专业之间的课程。
Web Intelligence and Big Data 涉及的面比较广，但每个点讲得都不深。如果想对这个领域有个全面了解和认识，可以听一下。不过讲课人略带口音，听起来有点别扭。
几门复杂网络（社交网络、经济网络分析等）课程都相当不错：Networked Life、Social Network Analysis、Social and Economic Networks: Models and Analysis，（还有一门 Networks: Friends, Money, and Bytes，我没听过，但据其他人评价应该不错），我从中学到了很多。而且我想，这里的概念和机器学习的联系也都是很紧密的。但复杂网络（其实大多是图论知识了）和机器学习的交叉，现在做的人还不太多，基本上物理和计算机两边还都是各做各的。这一块未来应该有不小发展空间。
Image and video processing: From Mars to Hollywood with a stop at the hospital 和 Computational Photography 都是入门课，适合想对图像处理有所了解的人听。讲课这两位老师都是大牛，算是深入浅出吧。
Functional Programming Principles in Scala，语言大师、Scala 创始人 Martin Odersky 亲授。我虽然没跟完，只听和做了前面三到四周的课和作业，但感觉很有收获。编程作业应该和 sicp 蛮相关的。能领会不少函数式编程的精神。
Neural Networks for Machine Learning，这门课由神经网络和深度学习的宗师 Geoffrey Hinton 开设，也是覆盖面很广。如果先对神经网络有一些了解与实践，再来听可能收获会更大。我就是当时听的时候很多东西都没理解，现在仍然在反复看。</description></item><item><title>浅析JNI（二）</title><link>https://whbzju.github.io/posts/qianxi-jni-2/</link><pubDate>Sun, 30 Jun 2013 09:55:00 +0800</pubDate><guid>https://whbzju.github.io/posts/qianxi-jni-2/</guid><description>上文：浅析JNI中提到，静态注册方法有不少弊端，和现在的链接方式方式分静态链接和动态链接相识，jni技术中还有动态注册，本文将详细介绍其实现机制和原理。
#动态注册
##Java层 先看代码，为hello-jni的java层添加动态注册的native方法，与静态注册的native方法比较。
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), &amp;quot;Call from Native&amp;quot;, Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System.loadLibrary(&amp;quot;learn-jni&amp;quot;); } }</description></item><item><title>浅析JNI(一)</title><link>https://whbzju.github.io/posts/qianxi-jni/</link><pubDate>Wed, 26 Jun 2013 22:31:00 +0800</pubDate><guid>https://whbzju.github.io/posts/qianxi-jni/</guid><description>最近的项目和一些图像处理有关，需要用C、C++实现，生成so文件，再通过JNI结合到Android的app中，有时候项目需要还会查看android的源码，做些调整，也会涉及到许多so文件，了解了一些JNI的技术。并且，正在读的一本书叫《深入理解Android》卷一，作者：邓平凡。该书是写的深入浅出，作者功力深厚，大力推荐购买。本文关于JNI的技术大部分参考该书第二章的内容，有兴趣的同学可以购买该书查看原文，这里作为我个人关于JNI的知识整理。
在进入正题之前，需要读者了解一些预备知识，比如关于JNI环境的配置，第一个jni程序hello-jni实现，具体参考：http://whbzju.github.io/blog/2013/06/01/android-jni-config/
#内容概述 本文从以下4个部分进行：
Java层，声明、使用native方法 Java与Native如何关联，即注册的方式与实现 Java与Native方法通信，即如何互相调用 Java与Native的数据结构对应关系 我相信，如果你弄懂了以上的问题，可以使用jni技术进行基本的开发。本文通过实现一个简单的demo，对以上的问题的进行解答。
#Java层&amp;mdash;声明、使用native方法 先看MediaScanner.java的代码
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); tv.setText( stringFromJNI() ); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 //public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), &amp;quot;Call from Native&amp;quot;, Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System.</description></item><item><title>入职两月总结</title><link>https://whbzju.github.io/posts/ruzhilianggeyuezongjie/</link><pubDate>Sun, 23 Jun 2013 09:01:00 +0800</pubDate><guid>https://whbzju.github.io/posts/ruzhilianggeyuezongjie/</guid><description>好久没有写博客，一是工作后时间不是自己，每天很晚下班，回到家，洗洗差不多就要睡了。二是公司信息安全管的很严，资料带不出来，工作方面的积累不方便写到博客上，每次想起要重新写自己写过的东西，就很没有动力。
本周过后，入职已经两个月了，公司的体制不想也没有资格评论，做的项目确是我很满意的，只能说塞翁失马焉知非福，找工作的时候千挑万选，也看不清进来后的项目，目前的情况还算幸运。现在的项目组涉及到的领域有Android开发、人脸识别、机器学习等，而且作为一个新的项目，我有幸可以从头开始接触整个项目。
##成长
Android源码环境调试app、系统组件 Android 4.0 人脸解锁app研究 Android JNI技术学习 人脸识别算法PCA、FDA、LBP学习 人脸检测HaarCascade学习 Opencv 人脸识别 Demo研究：Eigenface、fisherFaces、LBP。 机器学习LDA、贝叶斯学习 ##博客计划 后续博客将集中在三个领域
Android技术：分为源码和应用开发技术 人脸识别：集中于机器学习的方式实现 机器学习：未来重点 计划中的blog：
Android JNI技术简介 Android调试小技巧 PCA之我的理解 fisherFaces之我的理解 Opencv人脸识别Demo ADB的使用详解 Haar分类器训练 欠了好多，这些内容我在公司都有写过文档，可惜不能直接用，希望在整理的过程中有进一步的理解。</description></item><item><title>Android JNI MAC OS环境配置</title><link>https://whbzju.github.io/posts/android-jni-config/</link><pubDate>Sat, 01 Jun 2013 23:50:00 +0800</pubDate><guid>https://whbzju.github.io/posts/android-jni-config/</guid><description>##前言&amp;mdash;JNI技术简介 JNI是Java Native Interface的缩写，即“Java本地调用”，它是Java世界和Native世界的中介桥梁。其中Native世界一般指C/C++的世界。众所周知，Java是一种跨平台的语言，即Java编写的应用与平台无关。但是，计算机的世界在Java出现之前已经发展了很久，有很多优秀健壮的代码可以复用。比如Linux下的好多驱动模块、文件系统等。Java若去重新实现这些功能，未免费力不讨好，落下重复造轮子的名声。通过JNI技术，使用这些Native的模块，便成了一个折中的办法。同时，Java的世界依靠虚拟机构建，而虚拟机是native语言实现，并且虚拟机运行在具体的平台上，所以虚拟机本身是无法做到平台无关。通过JNI技术，可能做到在Java层的平台无关，即在Java层，底层的细节完全被屏蔽掉了。综合来讲，JNI技术一直支撑这Java世界，只不过我们平时接触的较少。
在Android的世界里，不允许纯C/C++的程序出现，但是它支持JNI，通过JNI来实现java和C/C++的交互。因此，JNI对于需要接触到Android源码、底层驱动、图形图像等领域的开发者来讲异常重要。
在Android中，Native语言实现的代码最终要编译成*.so动态库的方式，供java层调用，目前有两种途径实现。
##两种编译环境
源码编译环境：Android平台提供基于Make的编译环境，为App正确的编写Android.mk即可使用该编译环境，该环境需要通过git从Android的官方的源码平台获取源码并编译，得到环境。具体见：http://source.android.com/index.html 基于Android NDK的编译环境:NDK的全称叫做Native Development Kit。是google提供给我们用于本地编译JNI的工具。事实上，NDK和源码编译环境一样，都是使用Android的编译系统，通过Android.mk来控制编译。本文重点介绍这种方式。 ##NDK编译环境 在Mac下，配置NDK的环境十分简便，你只需要去官网下载ndk包，前提是你已经安装好ndk需要的工具，一般你如果安装过xcode，基本的环境都会有。解压缩到任意一个目录下，把该目录加到你的PATH中即可。比如我的：
在~/.bash_profile中把路径加入PATH，如果没有，可以创建一个.bash_profile，在最后加入下面语句。
export PATH=$PATH:/Users/youpath/android-ndk-r8e 重启bash，即可使用ndk-build
HaibotekiMacBook-Air:jni haibowu$ source ~/.bash_profile HaibotekiMacBook-Air:jni haibowu$ ndk-build ##运行Hello-jni ndk包解压缩之后，自带一些jni的例子，下面我们就来编译运行下hello-jni，感觉下jni的世界。该demo的路径在ndk安装路径的sample目录下。进入该路径，执行下列命令：
HaibotekiMacBook-Air:jni haibowu$ ndk-build Gdbserver : [arm-linux-androideabi-4.6] libs/armeabi/gdbserver Gdbsetup : libs/armeabi/gdb.setup Compile thumb : hello-jni &amp;lt;= hello-jni.c SharedLibrary : libhello-jni.so Install : libhello-jni.so =&amp;gt; libs/armeabi/libhello-jni.so 当系统提示生成*.so文件时，即代表编译成功。可以通过eclipse或者intellij idea导入该工程，运行查看效果。
##其他
如果你有android源码编译环境，你可以通过编写android.mk来编译app 如果你是在window下使用ndk，你需要安装cygwin，来模拟linux的环境，才能把ndk安装成功，其思想是一直的。参考：http://www.cnblogs.com/luxiaofeng54/archive/2011/08/13/2136982.html ndk是一个开发工具包，你也可以查看它的源码、进行编译，具体参考：http://glandium.org/blog/?p=2146 ##后续 接下来，我会写一篇介绍Jni的blog，希望能写的浅显易懂。</description></item><item><title>李安家庭三部曲杂想</title><link>https://whbzju.github.io/posts/lianjiatingsanbuqu/</link><pubDate>Fri, 29 Mar 2013 14:10:00 +0800</pubDate><guid>https://whbzju.github.io/posts/lianjiatingsanbuqu/</guid><description>&lt;p>最近少年PI的漂流很火，很少见的微博上一致的好评，可惜妹子正值考研的关键阶段，不好打扰。再加上自己经济上实在是拮据，也不想多给家里增添负担，只好作罢。至今为止有两部电影很想看却没看成，一部是它，另一部是阿凡达。当然，其中缘由大相径庭，谁叫生活变化这么快呢。&lt;/p>
&lt;p>写东西，对我来讲是自身思维的整理，把我想的虑的形成文字表达出来。一个是我觉得自己最近的思路混乱，经常无法将一个问题描述清楚，逻辑上缺乏锻炼，或者也有可能是自己对问题本身并没有一个成型的思路。所以最近想把内心的东西挖出来，写点东西理一理，再次加工。&lt;/p>
&lt;p>李安的电影我其实看的很少，小的是看过卧虎藏龙，后来读研的时候重新回顾了一遍。这个导演把每个镜头都拍的很美，很用心，在讲他想讲的东西，拍他想给我们看得东西，于是，整个片子中透露着一种美。真正的艺术家，不会去迎合大众，不会去矫揉造作，他应该做他自己，展现出他想展现的，不带名利的枷锁，这样的作品中自然透露着一种美。请允许我不断的用美这个词汇，因为我词穷。当一个艺术家在创作时不是往自己的内心挖掘，而开始在意外界的元素时，比如名利，就是他艺术消亡的开始。&lt;/p></description></item><item><title>Macbook air上手心得</title><link>https://whbzju.github.io/posts/mac-test/</link><pubDate>Sun, 24 Mar 2013 00:33:00 +0800</pubDate><guid>https://whbzju.github.io/posts/mac-test/</guid><description>&lt;p>#购机
即将毕业，手头正在用的Thinkpad 410要还给实验室，而原来本科时候用的benq S41突然坏了。没办法，还没有开始赚钱，却要先败家了。年前开始看笔记本，自从用了TP的机子后，很喜欢它的做工，用了3年，硬件上没出过什么问题。在电脑城逛了一圈，实在看不上其他品牌笔记本的做工（当时还没有考虑Apple），于是准备再入一个T430，价格在8k左右。我现在对电脑的需求如下：&lt;/p>
&lt;ul>
&lt;li>稳定，性能过得去，做工好。&lt;/li>
&lt;li>轻便，易携带&lt;/li>
&lt;li>主要是编程和写文档，不考虑玩游戏。&lt;/li>
&lt;li>主要工作环境是Linux&lt;/li>
&lt;/ul>
&lt;p>对于T410，我最大的不满是它太重了，刚开始还没有特别多的感觉，后来几次出差，背着它站一天，或者是回家的时候，看到它就觉得重，对自己来讲是个不小的折磨。由此，产生了买超级本的需求，看上了TP的T430U，当然也看了X1，不过X1实在太贵了，不是我们这种刚毕业的同学可以考虑的。在查阅了一些资料之后发现，T430U是混合硬盘，其效用只有在win的环境下才能得到发挥，而我对window越用越慢，一两年必须得重装的问题无法忍受，只好放弃它。&lt;/p>
&lt;p>在和同学聊起买机子的烦恼，flyingShang同学推荐我买mba，他自己用了2年，小彬同学也用了一年多，只有一个评论，&lt;strong>再也不想用别的电脑了&lt;/strong>。鉴于这两位好基友的推荐，开始考虑Mac，刚开始的时候担心air的性能，看了几款pro。新出的rmbp真的是很有吸引力，带retina屏，强悍的性能，价格比air贵一些，而且比原来的pro轻了不少。考虑到将来工作后主力机不是这台笔记本，还是省点钱吧，最终决定如个air。&lt;/p>
&lt;p>小彬同学的air是在&lt;a href="http://www.appletuan.com/">苹果团&lt;/a>上购买，mba 231低配8g定制版。于是我也想在上面买个一样的。可是等了好久，都不见231定制版的出现，只好向团主询问，得知他们不再发起mba 231 8g定制版的团购了，需要等到年中的时候，苹果出新款mba时，他们会组织团购新款。伤心之余只好死心，第二天在团上入了个mba 231低配，买的过程中被网银和信用卡恶心了，我的网银不知道怎么过期了，信用卡又被支付宝限额，折腾了好久才付款成功（第一次网购如此揪心）。隔一天后，机子到了，然后就是这几天一直在折腾、适应。&lt;/p>
&lt;p>#Mac系统初体验
刚上手的mac感觉和Thinkpad完全不一样，TP会让你觉得精干、耐*，而mac会让你有好好珍惜它的冲动。总体的做工和外观没什么可以挑剔，屏幕比我想象中的好，特别是比我的T410好，原来的T410在色彩成像上我比较不满意，有一次给同学做个页面，我这边看起是蓝的，在他机子上成了绿色。键盘我个人还是更喜欢T410的，不过适应一阵子应该还行。大赞的是air的触摸板，我没有买鼠标，觉得air是不需要鼠标的。&lt;/p>
&lt;p>###触摸板手势操作
刚买到的air在使用时，触摸板必须按下才能有点击效果，这个可以在系统偏好设置中对触摸板进行设置。而且在该设置界面，就有良好的用户教程，通过gif（动态图片的形式）说明每个手势的作用。不能说那个手势用的最多，我在该设置中启用了所有的手势，而且现在基本上每个手势都在用。感觉比较深的是，通过结合多个桌面，将不同的工作内容放在不同的桌面（通过四个手指向上的手势调整分配），再结合四个手指左右切换的手势或者是command+tab/command+shift+tab，能够极大的提高工作效率。&lt;/p>
&lt;p>###Mac系统使用逻辑简要心得&lt;/p></description></item><item><title>octopress custom-configuration 个性化配置</title><link>https://whbzju.github.io/posts/octopress-custom-config/</link><pubDate>Fri, 01 Mar 2013 09:25:00 +0800</pubDate><guid>https://whbzju.github.io/posts/octopress-custom-config/</guid><description>&lt;p>#概述
我使用的octopress默认的主题，但是它的一些页面设置不能满足我的需求。比如：&lt;/p>
&lt;ul>
&lt;li>导航栏&lt;/li>
&lt;li>个人介绍页面&lt;/li>
&lt;li>分类Categories&lt;/li>
&lt;li>sina微薄分享&lt;/li>
&lt;li>评论&lt;/li>
&lt;/ul>
&lt;p>好在octopress的可定制性非常强，其核心配置文件叫 `_config.yml, 基本上的配置都需要用到这个文件。它的逻辑比较简单，blog所有的配置都在这个文件，它的基本格式如下：&lt;/p>
&lt;pre tabindex="0">&lt;code># Disqus Comments
disqus_short_name:
disqus_show_comment_count:
&lt;/code>&lt;/pre>&lt;p>这是一个第三方的评论插件，通过简单的设置即可实现blog中加入评论。注意，该文件是基于yaml语法，：后面的空格不能省略。该文件还有许多其他的参数可以配置，其中本文主要关注的是：&lt;/p>
&lt;pre tabindex="0">&lt;code>
# list each of the sidebar modules you want to include, in the order you want them to appear.
# To add custom asides, create files in /source/_includes/custom/asides/ and add them to the list like &amp;#39;custom/asides/custom_aside_name.html&amp;#39;
default_asides: [asides/about.html, asides/weibo.html, asides/category_list.html, asides/recent_posts.html, asides/github.html, asides/twitter.html, asides/delicious.html, asides/pinboard.html, asides/googleplus.html]
&lt;/code>&lt;/pre>&lt;p>如注释中提到，asides的设置，关联的目录在&lt;code>/source/\_includes/custom/asides&lt;/code>。比如想要在右侧边栏中加入about me框，则需要在&lt;code>/source/\_includes/custom/asides/&lt;/code>中新建about.html。建议借用该目录下默认的about.html。&lt;/p>
&lt;pre tabindex="0">&lt;code>&amp;lt;section&amp;gt;
&amp;lt;h1&amp;gt;About Me&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;A little something about me.&amp;lt;/p&amp;gt;
&amp;lt;/section&amp;gt;
&lt;/code>&lt;/pre></description></item><item><title>Orange's一个操作系统的实现---心得与体会</title><link>https://whbzju.github.io/posts/tryos-xindetihui/</link><pubDate>Sat, 23 Feb 2013 15:57:00 +0800</pubDate><guid>https://whbzju.github.io/posts/tryos-xindetihui/</guid><description>&lt;p>#前言
本科的时候，室友有一本《自己动手写操作系统》，曾拿来翻了一翻，觉得十分有趣，可惜当时要应付考研，没有时间好好看这本书。后来读研之后，马上入了一本，不过此时该书已经是第二版，叫《Orange&amp;rsquo;s 一个操作系统的实现》，却因自己畏难和拖延不决，一直到今天，马上要毕业了从把此书匆匆过了一遍。
不得不说，佩服作者的功力和心态，作者像是一个小孩，认真的为大家讲述他心爱的玩具是如何搭建的。在如今，实现一个这样的操作系统，并没有什么使用价值，只能作为学习的demo。为了搭建这个玩具，作者需要去了解x86架构的运行原理，内存的分页分段实现机制，8259A中断控制的部分原理和使用方法，还有文件系统、硬盘等等，我想当当是阅读这些设备组件的文档，就要耗去许多功夫，更别说调试的功夫。故在这种没有外界事物驱动的项目，若非有极大的热忱，是无论如何也坚持不下去。而我却连读完这本书这件事情都拖了3年，想来真是惭愧。
#内容概述
整本书分为上下两篇，上篇的内容更为底层一些，因为本书是真正实现一个系统，所以上篇中有很多内容是有关硬件细节的，需要一定的汇编基础。下篇的内容则和我们平时接触的操作系统书籍有些类似，像IPC、文件系统、内存管理等更高级的话题，以C语言实现为主，也有部分汇编代码。内容大致分为：&lt;/p>
&lt;ul>
&lt;li>环境搭建&amp;mdash;bochs、linux&lt;/li>
&lt;li>cpu相关&amp;mdash;引导扇区、保护模式&lt;/li>
&lt;li>内核相关&amp;mdash;内核雏形、进程、输入输出&lt;/li>
&lt;li>进程通信IPC&lt;/li>
&lt;li>文件系统&amp;mdash;硬盘驱动和简单的文件系统&lt;/li>
&lt;li>内存管理&amp;mdash;fork、MM的简单实现&lt;/li>
&lt;li>让OS能够部署到真正的机器中
本文变不打算重复书中的实现细节，因为文字没有代码讲的清楚，作者的代码带有大量的注释，所有的细节都在其中。&lt;/li>
&lt;/ul>
&lt;hr></description></item><item><title>ubuntu 12.04安装bochs 2.3.5</title><link>https://whbzju.github.io/posts/bochs-config/</link><pubDate>Mon, 04 Feb 2013 23:37:00 +0800</pubDate><guid>https://whbzju.github.io/posts/bochs-config/</guid><description>&lt;p>一直对操作系统本身抱有一定的崇拜心理，可是长久以来都没有好好专研下这本书。趁着工作之前的最后一个寒假，希望能顺利完成这本书，对操作系统的认识有一个新的认识。&lt;/p>
&lt;blockquote>
&lt;p>工欲善其事，必先利其器
首先，我们先要配置出书本中模拟实验的环境，即虚拟机bochs的配置。众所周知，bochs的安装包版本是不带有调试功能的，只有通过编译bochs源码，才能启用debug模式。&lt;/p>
&lt;/blockquote>
&lt;p>##bochs 2.3.5源码编译
网上编译bochs的资料非常多，基本的问题都有解决方案，我重点讲不常见的问题。
&lt;strong>基本安装步骤&lt;/strong>
tar vxzf bochs-2.3.5.tar.gz
cd bochs-2.3.5
sudo ./configure &amp;ndash;enable-debugger &amp;ndash;enable-disasm
sudo make
sudo make install
bochs是c++实现的，因此其依赖环境会有build-esstianl g++ devlib等，需事先安装环境
sudo apt-get install build-essential
sudo apt-get install xorg-dev //GUI界面
sudo apt-get install bison&lt;/p>
&lt;p>在执行./configure时，出现apt-get orgx-dev后依旧出现仍然提示&lt;em>ERROR: X windows gui was selected, but X windows libraries were not found&lt;/em>&lt;/p></description></item><item><title>Ubuntu 12.04配置Octopress在Github上搭建blog</title><link>https://whbzju.github.io/posts/octopress-peizhi/</link><pubDate>Sat, 02 Feb 2013 11:04:00 +0800</pubDate><guid>https://whbzju.github.io/posts/octopress-peizhi/</guid><description>&lt;p>至从看到同学在Github上搭建的blog，深以为这才是我想要的blog，简洁漂亮，静态页面，离线编辑，markdown文档写作格式，git版本控制。所以当论文的事情告一段落，终于有时间来折腾它。起初，我在window平台上搭建，参考该&lt;a href="http://shanewfx.github.com/blog/2012/02/16/bulid-blog-by-octopress/">文献&lt;/a>配置，其中最大的问题是中文字符支持的问题。&lt;/p>
&lt;p>##内容概述&lt;/p>
&lt;ul>
&lt;li>ubuntu 12.04配置octopress和github Page&lt;/li>
&lt;li>git 配置问题，ssh key管理。&lt;/li>
&lt;li>维护已经存在的github blog&lt;/li>
&lt;li>vim的markdown语法高亮插件设置和所见即所得设置&lt;/li>
&lt;/ul>
&lt;p>##ubuntu 12.04配置octopress和github Page
首先，我们来了解下概念问题，关于octopress，可以见下文：&lt;/p>
&lt;blockquote>
&lt;p>Octopress is a blogging framework which generates your enire blog in static files. Octopress has integrated Twitter, Google Analytics, Google Plus, Facebook and some other webservices. There are also good plugins for adding images, code, videos and other content into your blog posts. The framework is made for hackers and people who know something about Linux and shell.There are three official ways to deploy Octopress
Github Pages
Heroku
Rsync&lt;/p>
&lt;/blockquote>
&lt;p>大致的意思是说octopress是一个静态页面生成框架，具有一些列集成的功能。有三种发布方式：Github Pages，Heroku和Rsync，本文采用Github Pages。由于Octopress是基于Ruby实现，我对ruby没有接触，从别人blog中了解到一下关于ruby的几个重要概念&lt;/p>
&lt;blockquote>
&lt;p>Gem ruby的easy install，用来安装各种库，是用ruby写的，全称叫rubygems。&lt;/p>
&lt;/blockquote>
&lt;p>Bundler 基于gem的更高级管理工具，bundler相对于gem就好比apt-get相对于aptitude。不过他不是单纯的下载安装，他会根据本目录的Gemfile文件，把你缺少的包给装上。
Rvm Ruby Version Manager，用来安装各种版本的ruby，问题是ubuntu有apt-get，这个不大派上用场。
Rbenv Simple Ruby Version Management，也是用来安装各种版本的ruby。
Rake Ruby Make，顾名思义就是ruby写的make，他对应的Makefile是Rakefile&lt;/p></description></item><item><title>Hello octopress</title><link>https://whbzju.github.io/posts/hello-octopress/</link><pubDate>Wed, 30 Jan 2013 15:27:00 +0800</pubDate><guid>https://whbzju.github.io/posts/hello-octopress/</guid><description>#Hello Octopress
This is my first octopress blog, just for test.
##中文 try chinese
##code
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;ldquo;Hello world\n&amp;rdquo;); return 0; }</description></item></channel></rss>