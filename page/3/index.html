<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.104.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Wujia's Blog</title><meta name=description content><meta name=author content><link rel=canonical href=https://whbzju.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://whbzju.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://whbzju.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://whbzju.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://whbzju.github.io/apple-touch-icon.png><link rel=mask-icon href=https://whbzju.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://whbzju.github.io/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Wujia's Blog"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://whbzju.github.io/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Wujia's Blog"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Wujia's Blog","url":"https://whbzju.github.io/","description":"","thumbnailUrl":"https://whbzju.github.io/favicon.ico","sameAs":["https://www.linkedin.com/in/haibo-wu-97b60759/","https://www.zhihu.com/people/wu-hai-bo"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://whbzju.github.io/ accesskey=h title="Wujia's Blog (Alt + H)">Wujia's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>如何在手机上实现高精度及自适应多种场景的计步器算法</h2></header><div class=entry-content><p>#前言 随着当前智能终端的普及，人们可做的事情变得越来越有趣，比如计步器。传统的计步器一般是一个单独的设备，戴在身体的某个位置，由于必须在用户身上增加一个设备，推广起来有一定阻力。其实，计步器只需要一个3-轴加速度传感器就能做到较高的记步精度，类似三星note3的计步器精度在95%以上。当前智能手机一般都含有加速度传感器，许多人开始在手机上做计步器。可惜目前Android市场上大多数计步器精度都不理想，经本人测试，目前最好的是三星的note3的健康伙伴，更关键的是三星使用了sensorhub的技术，在保持精度的同时，做到了超低功耗。 在手机上做计步器相较于传统的计步器最大的难点在于手机使用时位置不固定，计步器要能适应不同放置位置和不同走路场景，这就要求计步器算法有很好的动态调整能力。
#计步器模型介绍 关于人走路的模型，前人[1]已经做了很多研究，不再累赘。总结来讲，人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：
#算法
##概述
特征选取 滤波 基于动态阈值检测步数 步数矫正 ##特征选取 考虑到手机在不同放置情况下传感器的每个轴会有不同表现，因此，取其强度特征可以避免该类问题，即取三轴平方和。
##滤波 滤波是一种常见的数据预处理方法，特别是手机上加速度传感器数据存在一定的噪音，经过滤波后能得到较平滑的数据。滤波算法有许多中，常见的有数字滤波，也可以叫中值滤波、高斯滤波、快速傅里叶变换。本人试过几种滤波算法后，发现采用中值滤波即可满足需求，因为算法的瓶颈并不在此。另一个考虑是终端的计算资源有限，过多的计算将造成大量的耗电。
简单来讲，即取一个时间窗做平滑，假设以50HZ的频率采集加速度传感器数值，即在Android中注册Sensor频率为Fastest（不同手机可能会有差异）。我采用5个数据做一次平滑，即收到5个数据算一次平均值，当做当前值。当然，你可以增加时间窗长度，但是需要考虑用户体验，不能延迟太久。
##动态阈值 通常，计步器有两种思路：一种是通过计算过零率来记步；另外一种是计算极大值和极小值，判断峰谷值来记步。两种算法的思想类似，都需要设置阈值。为了适应各种不同的位置和走路姿势，你不能简单设一个阈值来检测步数。第一种方法容易出现误记，需要结合其他方法排除在mean值附近抖动的数据。第二种方法容易出现漏检，同时如果误记，还会影响到后续的记步，因为在一次步伐中出现好几个峰谷是很正常的，如何去除这些数据的影响需要良好的设计。
本人采用的检测峰谷值得方法记步，但不是通过计算极大值和极小值，而是设置波峰的阈值和波谷的阈值，即当数据大于波峰阈值时，都记为未确认峰值，保存其中最大的一个，这样可以避免数据在上升途中偶尔出现的抖动。同理，作用于峰谷。 检测出峰谷之后，通过保存一个时间窗，通过里面的峰谷个数记步。这里更多的是工程上的设计。
##步数矫正 基本思想是人类走路的特性，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔&lt;200ms和>2000ms，认为是无效步数。这部分也是目前终端计步器算法的核心，做的好的公司都有相应的矫正机制。
#总结 计步器算法的基本思想大致如此，最终产品的表现还要不断打磨，针对异常场景进行优化。最后，终端设备上应用不可避免的是功耗问题，如果开了计步器，你的手机用半天就没电，估计没人愿意用。目前市场上许多低功耗计步器算法，大多以降低精度为代价。目前看来只有三星采用高通的sensorhub方案有较好的表现。
参考：
[1] 利用3轴数字加速度计实现功能全面的计步器设计
[2] Github上的一个计步器实现代码 改代码直接使用效果不好</p></div><footer class=entry-footer><span title='2013-12-27 22:58:00 +0800 +0800'>December 27, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 如何在手机上实现高精度及自适应多种场景的计步器算法" href=https://whbzju.github.io/posts/pedometer/></a></article><article class=post-entry><header class=entry-header><h2>编程小扎之回调</h2></header><div class=entry-content><p>在我的认知中，编程最需要要关心的是数据结构和消息机制。进一步，即模块功能的定义，以及模块之间的通信。这和编程中的回调机制十分类似。回调在wiki中有如下定义：
In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback. The ways that callbacks are supported in programming languages differ, but they are often implemented with subroutines, lambda expressions, blocks, or function pointers....</p></div><footer class=entry-footer><span title='2013-09-20 14:49:00 +0800 +0800'>September 20, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 编程小扎之回调" href=https://whbzju.github.io/posts/bianchengzhihuidiao/></a></article><article class=post-entry><header class=entry-header><h2>C专家编程摘要</h2></header><div class=entry-content><p>上个月经人推荐，看了这本《C专家编程》，大赞，推荐用C的人都去看看。除了能从历史上了解 C语言的一些语法，还能学到一些常用规范。特别是指针和数组部分，很有收获。 用一张思维导向图总结</p></div><footer class=entry-footer><span title='2013-09-19 23:27:00 +0800 +0800'>September 19, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to C专家编程摘要" href=https://whbzju.github.io/posts/c-yuyuan/></a></article><article class=post-entry><header class=entry-header><h2>人脸识别实践总结</h2></header><div class=entry-content><p>#概述 前段时间接触了一阵子人脸识别，只能说是初窥门道，在这里做个总结。本文不涉及具体的算法原理，因为我都是参考别人的资料，只认为无法写的更好，在这边做个归纳总结。 现需求如下：从摄像头视频中识别出你自己或朋友的人脸
要实现这个需求，大体分为两个步骤，分别为人脸检测和人脸识别，即先要从摄像头中识别出人脸，即人脸检测，其次对检测到的人脸进行识别，即人脸识别。本文基于Opencv的人脸算法实现。
##人脸检测流程
选取特征（本文采用Haar-like特征） 选取分类器算法，训练人脸分类器（本文采用Adaboost级联分类器） 对图像进行人脸检测 ##人脸识别流程
选取人脸识别算法（本文包括PCA、FDA和LBP） 训练识别模型 对目标进行识别 #Opencv相关资料介绍 opencv在2.4后引入了人脸识别相关模块，原来只有人脸检测部分。在Opencv官网，有较详细的介绍，看 !目录，在该目录中重点要看这篇!Face Recognition with OpenCV.
这应该是一个德国人写的，在教程中他提到了3个算法：
EigenFaces FisherFace Local Binary Patterns Histograms 前面两个算法都是利用子空间的原理，有一定的相似性，分别以PCA和LDA为基础。后者以特征选取为主，做法思路都不大一样，建议分开看。该教程中对算法的描述过于简洁，不适合初学者看，建议寻找相关资料进一步阅读。 ##PCA-主成分分析法 PCA在很多地方都有应用，是一个十分简单有效的方法。其思想概括起来即降维，它认为原始数据中包含了大量的噪音和冗余，通过协方差矩阵的对角化可以得到一个子空间，该子空间的维度大大降低，却神奇的保留了原始数据中的显著特征。
该算法的具体原理可参考斯坦福大学的公开课，Andrew.Ng的机器学习课程，里面有一章节专门讲pca，若觉得看视频太慢，可以直接看讲义，讲的很清楚。国内有几个博客作者对它进行了翻译，推荐：
!主成分分析（Principal components analysis）-最大方差解释
!机器学习中的数学(4)-线性判别分析（LDA）, 主成分分析(PCA)
该算法涉及较多的线性代数知识，忘掉的同学建议复习下相关内容。
##LDA-线性判别分析 fisherface的FDA是在LDA基础之上的一种算法。关于线性判别的思想如下：它认为在PCA中，PCA把数据作为一个整体来看，即数据源中所有的显著特征都会被保留下来，如果一个人的脸在强光下和弱光下，pca生成的子空间有显著的差异，而他们却是同一张脸。LDA的思想是寻找一个分割平面（在二维中即直线），来区分两种不同类别的数据，既能够区分两个不同的人脸，进行归类。因此，它的目标就是怎么要找到这个平面，达到最好的区分效果。
同样，该算法的具体原理还是推荐Andrew.Ng的机器学习公开课。国内也有相关介绍，但是他们的数学推导让我不满意。
!线性判别分析（Linear Discriminant Analysis）（一） !线性判别分析（Linear Discriminant Analysis）（二）
##LBPH 该算法较上面二者容易理解，这里不做详细介绍，大家自己查找相关资料即可。
##Demo 上面教程中提到几个算法opencv中都有例子实现，当然要做2.4以上。教程讲了demo的位置和具体的使用。 所有的Demo需要一个人脸库，教程中提供了几个，可以下载。下载下来的人脸库需要预处理，即打上标签，作者提供了python脚步，大家可以使用。
有个demo值得关注，它实现了我们的需求，它有个专门的教程：!Face Recognition in Videos with OpenCV. 不过要想识别自己的脸，必须将自己的脸裁剪下来保存到人脸库中进行训练。
我不想自己拍照片去裁剪，我的做法是利用demo中的人脸检测算法，将我的人脸检测到，然后保存成灰度图，放到人脸库中。PS：这里有个问题，opencv自带的人脸检测分类器有可能会误捡，会把空白的墙壁当做人脸。我的做法是，在视频中指定一个矩形框，在这个矩形框中进行人脸检测，这样可以大大降低误捡率。实际操作中可以调整位置，让自己的人脸出现在矩形框中。
#Haar-like特征Adaboost级联分类器 完成了人脸识别的Demo验证，大家一定很好奇人脸检测是怎么实现的。opencv里面自带的检测算法原至两篇论文： P. Viola and M. Jones. Rapid object detection using a boosted cascade of simple features....</p></div><footer class=entry-footer><span title='2013-07-28 10:06:00 +0800 +0800'>July 28, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 人脸识别实践总结" href=https://whbzju.github.io/posts/renlianshibiezongjie/></a></article><article class=post-entry><header class=entry-header><h2>浅析JNI（三）</h2></header><div class=entry-content><p>没想到这个话题写到第三篇博客，写blog真费时，我的周末没了。接上文继续： PS更新:这篇blog一拖就是一个月，主要是我太懒了。其次是在公司写的东西不能带出来，每次要写这方面的资料，必须重写一些demo进行说明，重复劳动，没有动力。
#内容概述
JNI数据类型 JNIEnv介绍 ##JNI数据类型介绍
基本数据类型 先来看一张图： 可以明显的看出JNI的数据类型只是比java的基本数据类型多了个j。
引用数据类型 同样看图： 可以看出所有的引用类型都是jobject，和java类似。不过jni里面对jstring单独做了处理，就叫jstring类型，估计是用的频率太高，如果也是jobject会涉及到大量的“装箱拆箱“吧。
##JNIEnv介绍 JNIEnv是jni中举足轻重的一个角色，env可以理解成window中的句柄，线程中的线程描述符，或者简单理解成当前的上下文环境变量。在java VM中，它是一个局部引用，因此无法作为全局引用保存下来，每次在jni调用时，都要重新获取下env，因为env有可能会发生变化。
##实例讲解–Jni回调java 在工作中，我们使用jni时，常常会碰到需要从native回调java的需求，比如java通过jni调用native的一些函数，如果这些函数较为耗时，经常会起一个线程来完成任务，那么当任务完成时，必然要告诉java层。通常的做法是java层通过jni设置回调函数，native通过jni回调java。先看代码：
public class jniActivity extends Activity {
private TextView tv; //private String test; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); SetJniCallBack(); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // Java通过该方法设置回调方法 public native void SetJniCallBack(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast....</p></div><footer class=entry-footer><span title='2013-07-27 22:41:00 +0800 +0800'>July 27, 2013</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to 浅析JNI（三）" href=https://whbzju.github.io/posts/qianxi-jni-3/></a></article><article class=post-entry><header class=entry-header><h2>转：公开课点评（收藏用）</h2></header><div class=entry-content><p>#原文 !链接
今天在图灵Q群里聊到一些公开课心得。群友隋春宁建议我总结一下、发到社区。我也觉得这些信息可能对公开课同好有帮助，遂总结如下：
我觉得比较好的课程：
Algorithms: Design and Analysis, Part 1 和 Part2 都挺好的，算是理论和实践结合得很好、难度介于入门和专业之间的课程。
Web Intelligence and Big Data 涉及的面比较广，但每个点讲得都不深。如果想对这个领域有个全面了解和认识，可以听一下。不过讲课人略带口音，听起来有点别扭。
几门复杂网络（社交网络、经济网络分析等）课程都相当不错：Networked Life、Social Network Analysis、Social and Economic Networks: Models and Analysis，（还有一门 Networks: Friends, Money, and Bytes，我没听过，但据其他人评价应该不错），我从中学到了很多。而且我想，这里的概念和机器学习的联系也都是很紧密的。但复杂网络（其实大多是图论知识了）和机器学习的交叉，现在做的人还不太多，基本上物理和计算机两边还都是各做各的。这一块未来应该有不小发展空间。
Image and video processing: From Mars to Hollywood with a stop at the hospital 和 Computational Photography 都是入门课，适合想对图像处理有所了解的人听。讲课这两位老师都是大牛，算是深入浅出吧。
Functional Programming Principles in Scala，语言大师、Scala 创始人 Martin Odersky 亲授。我虽然没跟完，只听和做了前面三到四周的课和作业，但感觉很有收获。编程作业应该和 sicp 蛮相关的。能领会不少函数式编程的精神。
Neural Networks for Machine Learning，这门课由神经网络和深度学习的宗师 Geoffrey Hinton 开设，也是覆盖面很广。如果先对神经网络有一些了解与实践，再来听可能收获会更大。我就是当时听的时候很多东西都没理解，现在仍然在反复看。...</p></div><footer class=entry-footer><span title='2013-07-01 22:30:00 +0800 +0800'>July 1, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 转：公开课点评（收藏用）" href=https://whbzju.github.io/posts/gongkaikedianpian/></a></article><article class=post-entry><header class=entry-header><h2>浅析JNI（二）</h2></header><div class=entry-content><p>上文：浅析JNI中提到，静态注册方法有不少弊端，和现在的链接方式方式分静态链接和动态链接相识，jni技术中还有动态注册，本文将详细介绍其实现机制和原理。
#动态注册
##Java层 先看代码，为hello-jni的java层添加动态注册的native方法，与静态注册的native方法比较。
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); //tv.setText( stringFromJNI() ); tv.setText(DynamicStringFromJNI()); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), "Call from Native", Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System.loadLibrary("learn-jni"); } }...</p></div><footer class=entry-footer><span title='2013-06-30 09:55:00 +0800 +0800'>June 30, 2013</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to 浅析JNI（二）" href=https://whbzju.github.io/posts/qianxi-jni-2/></a></article><article class=post-entry><header class=entry-header><h2>浅析JNI(一)</h2></header><div class=entry-content><p>最近的项目和一些图像处理有关，需要用C、C++实现，生成so文件，再通过JNI结合到Android的app中，有时候项目需要还会查看android的源码，做些调整，也会涉及到许多so文件，了解了一些JNI的技术。并且，正在读的一本书叫《深入理解Android》卷一，作者：邓平凡。该书是写的深入浅出，作者功力深厚，大力推荐购买。本文关于JNI的技术大部分参考该书第二章的内容，有兴趣的同学可以购买该书查看原文，这里作为我个人关于JNI的知识整理。
在进入正题之前，需要读者了解一些预备知识，比如关于JNI环境的配置，第一个jni程序hello-jni实现，具体参考：http://whbzju.github.io/blog/2013/06/01/android-jni-config/
#内容概述 本文从以下4个部分进行：
Java层，声明、使用native方法 Java与Native如何关联，即注册的方式与实现 Java与Native方法通信，即如何互相调用 Java与Native的数据结构对应关系 我相信，如果你弄懂了以上的问题，可以使用jni技术进行基本的开发。本文通过实现一个简单的demo，对以上的问题的进行解答。
#Java层—声明、使用native方法 先看MediaScanner.java的代码
public class jniActivity extends Activity {
private TextView tv; /** * Called when the activity is first created. */ @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); //setContentView(R.layout.main); TextView tv = new TextView(this); tv.setText( stringFromJNI() ); setContentView(tv); } // 这个方法采用静态注册，参考ndk自带的例子hello-jni的实现 public native String stringFromJNI(); // 修改成动态注册 //public native String DynamicStringFromJNI(); // 提供方法，让native层调用 public void testMethodForNativeCallJava(){ Toast.makeText(getApplicationContext(), "Call from Native", Toast.LENGTH_SHORT).show(); } // 加载jni库 static{ System....</p></div><footer class=entry-footer><span title='2013-06-26 22:31:00 +0800 +0800'>June 26, 2013</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to 浅析JNI(一)" href=https://whbzju.github.io/posts/qianxi-jni/></a></article><article class=post-entry><header class=entry-header><h2>入职两月总结</h2></header><div class=entry-content><p>好久没有写博客，一是工作后时间不是自己，每天很晚下班，回到家，洗洗差不多就要睡了。二是公司信息安全管的很严，资料带不出来，工作方面的积累不方便写到博客上，每次想起要重新写自己写过的东西，就很没有动力。
本周过后，入职已经两个月了，公司的体制不想也没有资格评论，做的项目确是我很满意的，只能说塞翁失马焉知非福，找工作的时候千挑万选，也看不清进来后的项目，目前的情况还算幸运。现在的项目组涉及到的领域有Android开发、人脸识别、机器学习等，而且作为一个新的项目，我有幸可以从头开始接触整个项目。
##成长
Android源码环境调试app、系统组件 Android 4.0 人脸解锁app研究 Android JNI技术学习 人脸识别算法PCA、FDA、LBP学习 人脸检测HaarCascade学习 Opencv 人脸识别 Demo研究：Eigenface、fisherFaces、LBP。 机器学习LDA、贝叶斯学习 ##博客计划 后续博客将集中在三个领域
Android技术：分为源码和应用开发技术 人脸识别：集中于机器学习的方式实现 机器学习：未来重点 计划中的blog：
Android JNI技术简介 Android调试小技巧 PCA之我的理解 fisherFaces之我的理解 Opencv人脸识别Demo ADB的使用详解 Haar分类器训练 欠了好多，这些内容我在公司都有写过文档，可惜不能直接用，希望在整理的过程中有进一步的理解。</p></div><footer class=entry-footer><span title='2013-06-23 09:01:00 +0800 +0800'>June 23, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 入职两月总结" href=https://whbzju.github.io/posts/ruzhilianggeyuezongjie/></a></article><article class=post-entry><header class=entry-header><h2>Android JNI MAC OS环境配置</h2></header><div class=entry-content><p>##前言—JNI技术简介 JNI是Java Native Interface的缩写，即“Java本地调用”，它是Java世界和Native世界的中介桥梁。其中Native世界一般指C/C++的世界。众所周知，Java是一种跨平台的语言，即Java编写的应用与平台无关。但是，计算机的世界在Java出现之前已经发展了很久，有很多优秀健壮的代码可以复用。比如Linux下的好多驱动模块、文件系统等。Java若去重新实现这些功能，未免费力不讨好，落下重复造轮子的名声。通过JNI技术，使用这些Native的模块，便成了一个折中的办法。同时，Java的世界依靠虚拟机构建，而虚拟机是native语言实现，并且虚拟机运行在具体的平台上，所以虚拟机本身是无法做到平台无关。通过JNI技术，可能做到在Java层的平台无关，即在Java层，底层的细节完全被屏蔽掉了。综合来讲，JNI技术一直支撑这Java世界，只不过我们平时接触的较少。
在Android的世界里，不允许纯C/C++的程序出现，但是它支持JNI，通过JNI来实现java和C/C++的交互。因此，JNI对于需要接触到Android源码、底层驱动、图形图像等领域的开发者来讲异常重要。
在Android中，Native语言实现的代码最终要编译成*.so动态库的方式，供java层调用，目前有两种途径实现。
##两种编译环境
源码编译环境：Android平台提供基于Make的编译环境，为App正确的编写Android.mk即可使用该编译环境，该环境需要通过git从Android的官方的源码平台获取源码并编译，得到环境。具体见：http://source.android.com/index.html 基于Android NDK的编译环境:NDK的全称叫做Native Development Kit。是google提供给我们用于本地编译JNI的工具。事实上，NDK和源码编译环境一样，都是使用Android的编译系统，通过Android.mk来控制编译。本文重点介绍这种方式。 ##NDK编译环境 在Mac下，配置NDK的环境十分简便，你只需要去官网下载ndk包，前提是你已经安装好ndk需要的工具，一般你如果安装过xcode，基本的环境都会有。解压缩到任意一个目录下，把该目录加到你的PATH中即可。比如我的：
在~/.bash_profile中把路径加入PATH，如果没有，可以创建一个.bash_profile，在最后加入下面语句。
export PATH=$PATH:/Users/youpath/android-ndk-r8e 重启bash，即可使用ndk-build
HaibotekiMacBook-Air:jni haibowu$ source ~/.bash_profile HaibotekiMacBook-Air:jni haibowu$ ndk-build ##运行Hello-jni ndk包解压缩之后，自带一些jni的例子，下面我们就来编译运行下hello-jni，感觉下jni的世界。该demo的路径在ndk安装路径的sample目录下。进入该路径，执行下列命令：
HaibotekiMacBook-Air:jni haibowu$ ndk-build Gdbserver : [arm-linux-androideabi-4.6] libs/armeabi/gdbserver Gdbsetup : libs/armeabi/gdb.setup Compile thumb : hello-jni &lt;= hello-jni.c SharedLibrary : libhello-jni.so Install : libhello-jni.so => libs/armeabi/libhello-jni.so 当系统提示生成*.so文件时，即代表编译成功。可以通过eclipse或者intellij idea导入该工程，运行查看效果。
##其他
如果你有android源码编译环境，你可以通过编写android.mk来编译app 如果你是在window下使用ndk，你需要安装cygwin，来模拟linux的环境，才能把ndk安装成功，其思想是一直的。参考：http://www.cnblogs.com/luxiaofeng54/archive/2011/08/13/2136982.html ndk是一个开发工具包，你也可以查看它的源码、进行编译，具体参考：http://glandium.org/blog/?p=2146 ##后续 接下来，我会写一篇介绍Jni的blog，希望能写的浅显易懂。</p></div><footer class=entry-footer><span title='2013-06-01 23:50:00 +0800 +0800'>June 1, 2013</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Android JNI MAC OS环境配置" href=https://whbzju.github.io/posts/android-jni-config/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://whbzju.github.io/page/2/>«&nbsp;Prev&nbsp;</a>
<a class=next href=https://whbzju.github.io/page/4/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2022 <a href=https://whbzju.github.io/>Wujia's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>