<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>machine | Wujia's Blog</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://www.wujia.io/tags/machine/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><link rel=icon href=https://www.wujia.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.wujia.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.wujia.io/favicon-32x32.png><link rel=apple-touch-icon href=https://www.wujia.io/apple-touch-icon.png><link rel=mask-icon href=https://www.wujia.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://www.wujia.io/tags/machine/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="machine"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://www.wujia.io/tags/machine/"><meta name=twitter:card content="summary"><meta name=twitter:title content="machine"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.wujia.io/ accesskey=h title="Wujia's Blog (Alt + H)">Wujia's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://www.wujia.io/>Home</a>&nbsp;»&nbsp;<a href=https://www.wujia.io/tags/>Tags</a></div><h1>machine</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>Kaggle入门总结</h2></header><div class=entry-content><p>在知乎上看过一个答案，大意是有个地方叫kaggle，推荐搞机器学习的同学多上去撸一撸，实践出真知。同时还建议先把101系列的题目撸完，再选个感兴趣的比赛做。该答案详情见参考文献。
工具 有工程背景的同学，建议python，拥有不输给R的生态。主要用到以下工具：
ipython notebook + pandas + sklearn 在面对特别大的数据集，使用了公司的spark。
ipython notebook，神器，请参考我的另一篇blog Ipython Notebook对机器学习工程师的价值 pandas: 从工程过来的同学，首先请放弃循环之类的代码实现方式，拥抱dataframe。 sklearn：在github上非常活跃的项目，请多读官方文档。 spark：一般kaggle上比赛的数据量级是没有必要用它，但是最近有个比赛train的数据上百g了，所以试了下它。 比赛选择 首先，请从101系列中选几个做做，该系列一般有详细的教程，熟悉kaggle。接着选几个正在进行的比赛练手。一开始别贪心，注意下数据集的大小，当数据集大于几个g后，工程相关的工作会增加很多，同时对单机的性能有一定的要求，不利于初学者。但是，数据量大更符合真实的情况，比如做过一个ctr预估的比赛，无论是特征工程和模型训练都要更小心谨慎，每次试错的成本很高，随便训练一个模型都需要3-4小时，相应的这个比赛让我意思到sample的重要性，以及一个非常重要的特征处理方法featrue hashing.
本文将重点总结我在做自行车出租数量预测这个比赛的情况。该比赛介绍如下：
You are provided hourly rental data spanning two years. For this competition, the training set is comprised of the first 19 days of each month, while the test set is the 20th to the end of the month. You must predict the total count of bikes rented during each hour covered by the test set, using only information available prior to the rental period....</p></div><footer class=entry-footer><span title='2015-04-18 20:38:00 +0800 +0800'>April 18, 2015</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Kaggle入门总结" href=https://www.wujia.io/posts/kaggle-bike/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>random forest</h2></header><div class=entry-content><p>概述 知识背景要求 本文要求读者对机器学习中的一些基本概念有一定了解，比如特征，交叉验证，generation等概念。随机森林基于决策树模型，读者事先最好对决策树有一定的了解，若完全不了解，请将文中的tree抽象成能告诉你对错的一个black box，则不会影响理解。
目录 基本思想 理论保证 实践中常用的特性 实践效果验证 需要重点注意的 参考 基本思想 Ensemble method ensemble是当前主流机器学习领域一个非常流行的概念。引用sklearn的文档：
The goal of ensemble methods is to combine the predictions of several base estimators built with a given learning algorithm in order to improve generalizability / robustness over a single estimator.
其又分为两大类：averaging和boosting，分别以Random Forest和AdaBoost算法为代表。
Random Forest 引用wiki的定义：
Random forests are an ensemble learning method for classification, regression and other tasks, that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes (classification) or mean prediction (regression) of the individual trees....</p></div><footer class=entry-footer><span title='2015-02-16 15:09:00 +0800 +0800'>February 16, 2015</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to random forest" href=https://www.wujia.io/posts/random-forest/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>机器学习基石课程总结</h2></header><div class=entry-content><p>课程一开始，提了四个topic，what every machine learning user should know
* when can ml learn * why can ml learn * how can ml learn * how can ml learn better When can ml learn 首先，机器学习针对的场景，通过A对D和H学习一个g，用来描述最终的目标f，而这个事情无法简单的用规则搞定。其次，澄清各类细分ml场景的定义：
* 监督式 * 非监督式 * 增强学习 * 推进系统 * Activity学习，通过asking来学习 * Streaming why can ml learn * shatter的概念 * break point的概念 * generation问题 * VC维的概念 how can ml learn 讲了一些基本的linear方法，比如logistic regression，顺便提了下nonlinear的问题，通过transform将nonlinear映射到linear可分的空间，有点类似核函数，需要进一步确认。
how can ml learn better * overfiting * regularition，这块数学不错。从拉格朗日的constraint说起，到L1和L2的直观意义。 * cv * 三个重要的Principle。Occam's Razor， Sample Bias， Data Snooping....</p></div><footer class=entry-footer><span title='2014-12-28 11:07:00 +0800 +0800'>December 28, 2014</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 机器学习基石课程总结" href=https://www.wujia.io/posts/about-ml-fundation-course/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>ipython notebook对机器学习工程师的价值</h2></header><div class=entry-content><p>关键词：代码、数据、文档合一。
—-draft: false toc: true 如果选一个关键词来描述机器学习工程师的工作，不断试错是我心中的number one。相对于软件工程师来讲，有大量琐碎的dirty需要做，通常会占据到80%左右的时间。一个好的工具能够极大的提高效率。
总结需求如下：
可交互式的环境：比如预处理数据，有的时候数据比较大，比较耗时，希望能处理一次后就放在内存里面使用。 文档化，记录工作流。数据挖掘会有非常多的idea要去尝试，实现这些idea的代码会有微小的差异，需要一个工具能够统一追踪管理他们。且不同的实验会有不同的结果，整理这些结果形成文档太费时间，希望能够做完实验就生成文档。 经常会有一些片段代码要写，写在文件里有太零碎，写在交互式的shell里面有很难回溯，需要一个交互式和文档结合的工具。 支持可视化工具，兼容python画图 神奇的ipython notebook 安装环境 非常简单，推荐：Anaconda, 官网
ipython notebook入门 还是官网, 一开始不适应的同学，多看几个example吧。
分享你的ipython notebook 一键分享：A simple way to share Jupyter Notebooks
最后 附一张我的在kaggle上用ipython notebook做的一个入门题照：</p></div><footer class=entry-footer><span title='2014-11-23 16:17:00 +0800 +0800'>November 23, 2014</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to ipython notebook对机器学习工程师的价值" href=https://www.wujia.io/posts/ipython-notebook-bring-to-me/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>聚类算法中常见的距离计算方法</h2></header><div class=entry-content><p>概述 在面对聚类问题时，选择何种距离计算方法求相似度是一个basic question。文献[1]中提到了N多计算方法，从大类来看有以下几种：
$L_p$ Minkowski家族 $ L_1 $ 家族 Intersection 家族 Inner Product家族 etl 简单算一下大概有40+个计算方法，其中有好多没有听过。好在工业界一般只涉及到几个，本文将按自己理解大致介绍下这些方法及应用情况。 距离的类型和尺度 类型：
二进制（binary） 离散值（Discrete） 连续值(Continuous) 尺度：
定性：比如同义：red、green、black，比如顺序：高、中、低 定量： a) interval b) ratio 距离的类型和尺度非常重要，影响后续聚类算法的选择。 距离计算方法定义 严谨的定义参考[4]，通俗来讲，在一个空间内，距离计算方法满足以下4个公理。
$d(x,y) ≥ 0$ $ d(x,y)=0$ if $x=y$ $ d(x, y) = d(y, x)$ (distance is symmetric) $d(x, y) ≤ d(x, z) + d(z, y)$ (the triangle inequality). 在欧式空间，第四个公理可以直观理解为两点之间距离最短。在其他情况需要一些证明才能推导。
常见的距离计算方法 Lr norm 在n维空间，其计算公式如下：
$d(x,y)=(\sum_{k=1}^{n} |x_k-y_k| ^r)^{1/r}$
欧式距离 当r=2，这就是我们熟悉的欧式距离，其聚类形状在二维空间是一个圆。归属于$L_2$ norm
曼哈顿距离 r=1，归属于$L_1$ norm，其名字的来源与该距离计算过程有关。该距离类似在x和y的每个维度上沿grid line上travel，类似曼哈顿的街道。...</p></div><footer class=entry-footer><span title='2014-11-22 22:01:00 +0800 +0800'>November 22, 2014</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to 聚类算法中常见的距离计算方法" href=https://www.wujia.io/posts/ml-distance-measure/></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.wujia.io/>Wujia's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>